# 原型模式

## 一、原型模式

**意图：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**主要解决：**在运行期建立和删除原型。

**何时使用：**

1. 当一个系统应该独立于它的产品创建，构成和表示时。 
2. 当要实例化的类是在运行时刻指定时，例如，通过动态装载。 
3. 为了避免创建一个与产品类层次平行的工厂类层次时。
4. 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

**如何解决：**利用已有的一个原型对象，快速地生成和原型对象一样的实例。

**关键代码：** 

1. 实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()；
2. 原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。

## 二、浅拷贝与深拷贝

- 浅拷贝：只会复制引用，不会复制数据本身，浅拷贝得到的对象跟原始对象共享数据；
- 深拷贝：不仅会复制引用，还会复制数据本身，深拷贝得到的是一份完全独立的对象。

在 Java 语言中，**Object 类的 clone() 方法执行的就是浅拷贝，它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身**。

如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险；

如果操作非常耗时，推荐使用浅拷贝，否则应当使用深拷贝。

实际java项目中，我们一般采用CGLIB提供的工具类进行Bean的拷贝。

## 三、优缺点

### 优点

- ###### 性能提高。 

- ###### 逃避构造函数的约束。

### 缺点

1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 

2、必须实现 Cloneable 接口。

## 三、使用场景

开源架构中的使用：

1. Spring的BeanUtils.copyProperties方法复制一个对象的属性到另一个对象。
2. apache的Commons-beanutils包中的cloneBean方法实现浅拷贝等。



## 四、实现

