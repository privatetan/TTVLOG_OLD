# 死锁

## 什么是死锁？

两个或者多个线程申请资源时，互相持有对方所需要的资源，导致线程处于等待状态；

## 死锁产生原因？

竞争资源且分配资源的顺序不当；

## 死锁的产生四个必要条件？

1. ###### 互斥使用

   一个资源每次只能被一个线程使用；

2. ###### 不可抢占

   线程所获的的资源，在没有使用完成时，不能被强行剥夺；

3. ###### 占有且等待

   一个线程因请求新的资源而被阻塞等待时，对已持有的资源不释放；

4. ###### 循环等待

   多个线程间形成相互等待资源的状态。

## 解决死锁？

三种思路：

1. #### 不允许死锁发生（常用）

   - ###### 静态策略：预防死锁

     思想I. 竞争资源和分配资源顺序保持一致；

     思想II. 破坏死锁发生的四个必要条件之一即可；

     - **破坏互斥使用**：无法预知是否一定不访问资源，所以不能采用该方法。

     - **破坏不可抢占**：线程在申请新的资源时不能立即得到满足时，必须释放自身持有的所有资源。

     - **破坏占有且等待**：

       a. 要求线程一次性申请所有需要资源，有一个资源申请失败，其他资源也不会分配给该线程；

       b. 线程在申请新的资源时，必须先释放自身持有的所有资源。

     - **破坏循环等待**：线程必须按照规定的顺序申请资源；

   - ###### 动态策略：避免死锁

     思想：在系统分配资源时，先计算资源分配的安全性；

     银行家算法：线程在申请资源时，系统会进行资源的试分配，如果安全，则按照试分配方案分配，否则不分配。（两个过程：资源试分配+安全性检测）

2. #### 允许死锁发生

   - ###### 死锁检测

   - ###### 死锁解除

3. #### 不会发生死锁

   - ###### 忽略死锁

## 查看死锁？

java使用jstack命令： jstack  \<pid>