# 数据库事务

数据库的一组操作要么全部成功，要么全部失败；

是指多个数据库操作组成一个逻辑执行单元，满足 ACID 四个条件。

## 一、ACID

```
A: 原子性    -即这些操作要么全部成功，要么全部不成功，不存在中间状态；
C: 一致性    -数据库从一个状态转移到另外一个状态，数据完整性约束不变。
I: 隔离性    -一个事务的执行不会影响另外一个事务；
D: 持久性    -已提交对数据库的修改，应该永久保留在数据库中。
```

在MySQL上，InnoDB存储引擎支持事务，但是MyISAM存储引擎不支持事务。（这个是为了引导面试官问两个引擎的区别）

InnoDB 存储引擎是通过**MVCC**来支持事务的。（到这一步，停下来，接下来，面试官极大概率问你什么是MVCC）

关键点：ACID，innodb 通过 MVCC 支持事务

<img src="img/transaction.png" alt="数据库事务" style="zoom:25%;" />

## 二、MVCC（多版本并发控制）

##### 什么是 MVCC

```
* MVCC，多版本并发控制，是通过保存数据在某个时间点的【一致性数据快照】（Snapshot）来实现的。
* InnoDB存储引擎主要是通过【undo log】 和【事务版本号】来实现多版本（MVCC），利用锁机制来实现并发控制。
```

##### MVCC实现原理

```
对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：
* DB_ROW_ID：隐藏的自增ID，如果表没有主键，InnoDB会自动按row ID产生一个聚集索引树。
* DB_TRX_ID：事务ID，记录最后一次修改该记录的事务ID。
* DB_ROLL_PTR：回滚指针，指向上一个版本数据在undo log 里的位置指针；
大致原理：
1. InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中；
2. 如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录；
3. 其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。
```

##### MVCC的好处

```
MVCC 最大的好处是读不加锁，写时使用排他锁，读写不冲突，极大地增加了 MySQL 的并发性。
通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。
MVCC不存在幻读问题：快照读的情况下可以避免幻读问题，在当前读的情况下则需要使用间隙锁来解决幻读问题的。
```

##### 快照读与当前读

###### 快照读

```
快照读是指读取数据时不是读取最新版本的数据，而是基于历史版本读取的一个快照信息（mysql读取undo log历史版本) ;
快照读可以使普通的SELECT读取数据时不用对表数据进行加锁，从而解决了因为对数据库表的加锁而导致的两个如下问题:
1、解决了因加锁导致的修改数据时无法对数据读取问题;
2、解决了因加锁导致读取数据时无法对数据进行修改的问题;
```

###### 当前读

```
当前读是读取的数据库最新的数据，当前读和快照读不同，因为要读取最新的数据而且要保证事务的隔离性，所以当前读是需要对数据进行加锁的
（update, delete, insert, select ....lock in share mode, select for update 为当前读）
```

<img src="img/mvcc原理.png" alt="数据库事务" style="zoom:45%;" />

## 三、Read View（一致性视图）

InnoDB支持MVCC多版本，其中RC（Read Committed）和RR（Repeatable Read）隔离级别是利用consistent read view（一致读视图）方式支持的。 所谓consistent read view就是在某一时刻给事务系统（trx_sys）打snapshot（快照），把当时trx_sys状态（包括活跃读写事务数组）记下来，之后的所有读操作根据其事务ID（即trx_id）与snapshot中的trx_sys的状态作比较，以此判断read view对于事务的可见性。

##### Read View中保存的事务系统状态

```
* low_limit_id：当前系统最大事务版本号+1；
* up_limit_id：系统正处于活跃事务最小版本号；
* low_limit_no：trx_no小于view->low_limit_no的undo log对于view是可以purge(清理)的；
* rw_trx_ids：读写事务(未提交)数组；
* creator_trx_id：当前read view的事务版本号（事务ID）；
```

##### Read View 匹配条件

```
1. 数据事务ID < up_limit_id(view中最小事务ID) 则显示;
2. 数据事务ID >= low_limit_id(view中最大事务ID) 则不显示；
3. up_limit_id <= 数据事务ID < low_limit_id 则与活跃事务集合trx_ids里匹配；
4. 不满足read view条件时候，从undo log里面获取数据；
```

##### RC与RR隔离级别的Read View

```
* RC(read commit) 级别下同一个事务里面的每一次查询都会获得一个新的read view副本,这样就可能造成同一个事务里前后读取数据可能不一致的问题（重复读）;
* RR(重复读)级别下的一个事务里只会获取一次read view副本，从而保证每次查询的数据都是一样的。
```

在innodb 中每个SQL语句执行前都会得到一个read_view。副本主要保存了当前数据库系统中正处于活跃（没有commit）的事务的ID号，其实简单的说这个副本中保存的是系统中当前不应该被本事务看到的其他事务id列表。

`innodb`引擎会给每张表加一个隐含的列，存储的是事务版本号。当修改数据的时候，会生成一条对应的`undo log`，`undo log`一般用于事务回滚，里面含有版本信息。简单来说可以认为`undo log`存储了历史版本数据。每当发起查询的时候，`MySQL` 依据隔离级别的设置生成`Read View`，来判断当前查询可以读取哪个版本的数据。例如，在已提交读的隔离级别下，可以从`undo log`中读取到已经提交的最新数据，而不会读取到当前正在修改尚未提交的事务的数据。

## 四、隔离级别

数据库的隔离级别有四种：

```
1. 未提交读，Read Uncommitted：事务可以读取另外一个事务没有提交的数据。        问题：脏读，不可重复读
2. 提交读，Read Committed： 事务只能读取到另外一个已经提交的事务数据。         问题：     不可重复度
3. 重复读，Repeatable Read:  事务执行过程查询结果都是一致的，innodb 默认级别。
4. 串行化，Serializable:  读写都会相互阻塞。                               问题：
```

InnoDB的隔离级别实现（支持）：

### 多版本控制（MVCC）

```
innodb 引擎利用了 `Read View` 来支持提交读和重复读。`Read View`里面维护这三个变量：

1. up_limit_id：已提交事务ID + 1
2. low_limit_id：最大事务ID + 1
3. txn_ids：当前执行的事务ID

提交读这个级别，默认读取是不加锁的，只有修改才会加锁。简单来说，已提交读，是每次查询都生成一个新的`Read View`，所以永远都能看到已经提交的事务。

可重复读则是在第一次查询生成`Read View`之后，后面的查询都是使用这个`Read View`。
```

### 快照隔离（Snapshot Isolation）

```
innodb 引擎的可重复读隔离级别，要比定义的隔离级别更加严苛一点。一般的可重复读，无法解决幻读的问题。比如说原本你事务里面查询订单信息，这个时候又插入了一个新的订单，那么这种时候，幻读就会导致我们下一个查询就会查询到这条记录。但是 innodb 引擎的隔离级别并不会出现这个问题。

因为 innodb 引擎使用了临键锁，在“当前读”，也就是写的时候，锁住了记录之间的空档，防止插入数据。（这里面，不需要解释临键锁，等面试官提问）
```

## 五、日志（binlog、redo log、undo log）

值得注意：redo log属于物理日志， binlog、undo log属于逻辑日志

### Undo log（回滚日志）

在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。

##### Undo log 的用途

```
1. 保证事务进行回滚时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复；
2. 用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本；
```

### Binlog（二进制日志）

主要用于复制和数据恢复，记录了写入性的操作。`binlog`分成基于语句（Statement）、基于行（Row）、混合模式（Mixed）三种复制模式；

### Redo log（重做日志）

是InnoDB引擎产生的，主要用于支持MySQL事务，MySQL会先写`redo log`，而后在写`binlog`。redo log可以保证即使数据库异常重启，数据也不会丢失;

### 扩展binlog和redo log 写入的细节

### 1.、两阶段提交

因为`redo log`生成到`binlog`写入之间有一个时间差，所以为了保证两者的一致性，MySQL引入了两阶段提交:

```
1. Prepare阶段：写入`redo log`；
2. Commit阶段：写入`binlog`，提交事务；
```

### 2、刷盘时机

```
1. `binlog` 刷盘可以通过`sync_binlog`参数来控制。0-系统自由判断，1-commit刷盘，N-每N个事务刷盘;
2. `redo log`刷盘可以通过参数`innodb_flush_log_at_trx_commit`控制。0-写入`log buffer`，每秒刷新到盘；1-每次提交；2-写入到`OS cache`，每秒刷盘；
```

### innodb 引擎和 MyISAM 引擎的区别

分析：很多人陷入的一个误区，就是死记硬背所有的区别，面试的时候一紧张，又忘了。其实大可不必，记住几个关键点就可以了，因为面试官不一定就把所有的点都记得。说实在，这个问题完全就是为了面试而面试，因为在当前大家选择`MySQL`一般都默认使用`innodb`引擎的时候，讨论这个区别没有太大实际意义。万一不幸的是你们公司用的是MyISAM引擎，那就要仔细回答，方方面面照顾到。

答案：innodb 引擎和 MyISAM 最大的区别是事务、索引、锁支持。

1. innodb 引擎支持事务，而 MyISAM 不支持；
2. innodb 引擎的主键索引的叶子节点存放的是数据本身，而MyISAM存储的是数据的地址，需要再一次寻址；
3. innodb 支持行锁，而MyISAM 只支持表锁，因此`innodb`支持的并发粒度更细更高；

一般来说，在不使用事务，数据读多写的时候，又或者机器比较差的时候，用MyISAM比较合适。

### 为什么事务提交了但是数据没有保存

分析：这个问题呢，因为它和ACID的特性有冲突，所以是一个装逼点。一般不做 DBA，没踩过这一类的坑的人，比较容易忽略这一点。在前面提到 ACID 的 D 的时候，如果你记得这个，就可以主动说。整体来说，这是一个稍微高级一点的话题，所以要把握尺度，对这方面了解比较深刻，就一定要刷一波；如果感觉对面的面试官了解不深，也可以刷一波。

答案：在MySQL的innodb引擎中，事务提交后，必须将数据刷盘到磁盘上，如果在事务提交之后，没来得及刷到磁盘，就会出现事务已经提交，但是数据丢失了。（回到这一步你要开始判断，如果你是主动聊的，那就停下来，等面试官追问；如果这是面试官问的，那就接着答细节）MySQL的innodb引擎，事务提交的关键是将`redo log`写入到`Log buffer`，而后MySQL调用`write`写入到`OS cache`，只有到最后操作系统调用`fsync`的时候，才会落到磁盘上。

（为了方便记忆，记住这个过程：`commit` -> `log buffer` -> `OS cache` -> `fsync`）
（下面这一段是可选）
数据库有一个参数 `innodb_flush_log_at_trx_commit` 可以控制刷盘的时机：

1. 0，写到`log buffer`, 每秒刷新；
2. 1，实时刷新；
3. 2，写到`OS cache`, 每秒刷新

（接下来步入终极装逼环节，为了表达我们对这个问题的深刻理解，对OS的一般理解，我们得扩充一下回答面，慎用）

Redis的`AOF`机制也面临类似的问题，即`AOF`也不是立刻刷盘，而是写入到了`OS cache`，等到缓冲区填满，或者`Redis`决定刷盘才会刷到磁盘。而`redis`有三种策略控制，`always` 永远, `everysec` 每秒, `no` 不主动。默认情况下`everysec`，即有一秒钟的数据可能丢失。

（最后升华一下主题）
对于大多数要和磁盘打交道的系统来说，都会面临类似的问题，要么选择性能，要么选择强持久性。

关键字：提交不等于落盘了，`fsync`

#### 如何引导

1. 从`Redis` AOF 引过来，两边讨论的都是同一个主题；
2. 回答`ACID`的时候引导过来；
3. 讨论磁盘 IO 的时候看情况；
4. 讨论操作系统文件系统的时候，看情况；

核心就是，涉及到了`OS cache`，`fsync`等点，就可以引导来这边。

## Reference

[一文理解MySQL MVCC](https://zhuanlan.zhihu.com/p/29150809)
[innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/2014/08/20/innodb-lock.html)
