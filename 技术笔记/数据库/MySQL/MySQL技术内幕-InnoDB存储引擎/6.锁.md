# 锁

## 一、锁

数据库系统提供锁是为了支持共享资源进行并发访问，提供数据的完整性和一致性。

不同的数据库，不同的存储引擎对于锁的实现都是有差异的。

InnoDB锁的实现和Oracle数据库锁的实现非常类似，提供一致性的非锁定读、行级别锁支持。

## 二、Lock锁与Latch锁

Lock与Latch，在数据库中都被称作锁；

- ###### Lock（数据库资源锁）
  
  lock，作用于事务，用来锁定数据库中的对象，如表、页、行；
  
  lock的对象想仅在事务Commit或者Rollback后进行释放；
  
  lock，具有死锁检测机制。
  
  lock，可通过show engine innodb status查看相关信息；

- ###### Latch（线程锁，作java锁理解）
  
  latch，作用于线程，称为闩锁，是一种轻量级锁，要求锁定的时间非常短；
  
  latch，在InnoDB中可分为mutex（互斥量）和rwlock（读写锁）；
  
  latch，是用来保证并发线程操作临界资源的正确性；
  
  latch，没有死锁检测机制。
  
  latch，可通过show engine innodb mutex查看相关信息；

###### Lock锁与Latch锁的比较

| 比对项  | lock锁                                     | latch锁   |
|:----:|:-----------------------------------------:|:--------:|
| 对象   | 数据库资源                                     | 内存资源     |
| 作用于  | 事务                                        | 线程       |
| 保护   | 数据库内容                                     | 内存数据结构   |
| 持续时间 | 整个事务过程                                    | 临界资源     |
| 模式   | 行锁、表锁、意向锁                                 | 读写锁、互斥量  |
| 死锁   | waits-for gragh、time out机制<br />进行死锁检测及处理 | 无死锁检测机制  |
| 存在于  | Lock Manager存在于哈希表中                       | 每个数据结构对象 |
|      |                                           |          |

## 三、InnoDB中的Lock锁

### 1）锁的类型

InnoDB支持多粒度锁定，即允许事务在行级锁与表级锁同时存在

InnoDB支持两种粒度锁：

- ###### 表级锁

- ###### 行级锁

InnoDB中实现了两种行级锁：

- ###### 共享锁：S Lock，允许事务读一行数据。

- ###### 排他锁：X Lock，允许事务更新或删除一行数据。

InnoDB默认支持的是行锁，并且也支持表锁；

InnoDB并不是在数据行上加锁，而是在对应的索引上加锁；

###### 行级锁兼容性（兼容性是指对同一记录的兼容情况）

| 锁类型  | 排他锁X | 共享锁S |
| :-----: | :-----: | :-----: |
| 排他锁X | 不兼容  | 不兼容  |
| 共享锁S | 不兼容  |  兼容   |

X锁与任何锁都不兼容，S锁只能和S锁兼容；

###### 意向锁（Intention Lock）

意向锁：将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度的对象上加锁；

意向锁，为表级别的锁；

由于InnoDB支持的是行级锁，所以意向锁不会阻塞除全表扫描意外的任何请求；

对细粒度的对象（行）进行上锁（行级锁）时，首先就要对粗粒度的对象（表）上锁（意向锁）；

InnoDB支持两种表级意向锁：

- ###### 意向共享锁：IS Lock，事务想要获得一张表中某几行的共享锁；

- ###### 意向排他锁：IX Lock，事务想要获得一张表中某几行的排他锁；

###### InnoDB锁兼容性

|  锁  |   IS   |   IX   |   S    |   X    |
| :--: | :----: | :----: | :----: | :----: |
|  IS  |  兼容  |  兼容  |  兼容  | 不兼容 |
|  IX  |  兼容  |  兼容  | 不兼容 | 不兼容 |
|  S   |  兼容  | 不兼容 |  兼容  | 不兼容 |
|  X   | 不兼容 | 不兼容 | 不兼容 | 不兼容 |

X锁与任何锁都不兼容。

### 2）一致性非锁定读

###### 一致性非锁定读：

一致性非锁定读：InnoDB通过行的多版本控制（Multi versioning）方式来读取当前执行时间数据库中执行的数据；

一致性非锁定读中，如果读取的行正在进行Delete或者Update操作，InnoDB会去读取行的快照数据（Undo log）；

###### 快照数据（Undo log）：

快照数据，是事务修改行记录的旧版本数据，通过Undo段来完成；

快照数据，用作事务回滚数据；

快照数据，没有对历史数据进行修改，则无需加锁操作；

###### 多版本并发控制（MVCC）

每行记录可能有多个版本，即每行记录可能有多个快照数据，由此带来的并发控制，称为多版本并发控制（Multi Version Concurrency Contorl，MVCC）；

在事务隔离级别Read Commited 和 Repeatable Read（InnoDB默认事务隔离级别）下，InnoDB都是使用一致性非锁定读。但是对于快照数据的定义却不相同：

- Read Commited下，非一致读总是读取被锁定行“**最新一份**”的快照数据；
- Repeatable Read下，非一致读总是读取被锁定行“**事务开始时**”的快照数据。

### 3）一致性锁定读

显示地对数据库读取操作进行加锁，以保证数据逻辑的一致性；

InnoDB对于Select语句支持两种一致性的锁定读操作：

- select ... for update：对读取的行记录加X锁，阻塞其他锁；
- select ... lock in share mode：对读取的行记录加S锁，阻塞X锁；

使用一致性锁定读必须在一个事务中，事务提交，锁释放；即使用时，需加上Begin，start transaction或者set autocommit=0；

### 4）自增长与锁

自增长是MySQL首选的主键实现方式；

###### 自增长计数器

InnoDB中，每个含有自增长值的表都会有一个自增长计数器；

###### Auto-Inc Locking

对含有自增长值的表进行insert插入操作时，会先获取计数器的值，然后对自增长计数器值+1操作，这种方式称作Auto-Inc Locking；

Auto-Inc Locking，采用特殊的表锁机制实现，该锁的释放是在完成自增长插入SQL语句后立即释放，而非等待事务完成；

###### 互斥量

MySQL5.1.22版本开始，InnoDB提供了一种轻量级互斥量的自增长实现机制，提高了自增长值插入性能。

InnoDB与MyISAM中的自增长实现方式不同，MyISAM采用表锁设计，自增长无需考虑并发插入问题。

InnoDB中，自增长列必须是索引，且必须是索引的第一个列。

### 5）外键与锁

对于一个外键列，如果没有显式对该列添加索引，InnoDB会自动对其添加一个索引，可以避免表锁；（oracle不会自动创建索引，需手动添加，这可能会导致死锁）

对于外键的插入或者更新，首先会使用一致性锁定读（添加S锁）方式查找父表中的记录，使用一致性锁定读，而非一致性非锁定读的原因在于，非锁定读可能会导致数据不一致问题。



## 四、锁的算法

### 1）行锁的三种算法

- ###### Record Lock：行记录锁，单个行记录的锁

  总是会锁定索引记录，没有建立索引时，InnoDB会锁定隐式的主键。

- ###### Gap Lock：间隙锁，锁定一个范围（开区间），但不包含记录本身

  Gap Lock作用是为了让阻止多个事务将记录插入到同一范围，但是会导致Phantom Problem问题；

- ###### Next-Key Lock：Gap Lock+Record Lock，锁定一个范围（前开后闭），包含锁定记录本身

  InnoDB对于行的查询都采用这种锁定算法。

  Next-key Lock采用Next-key locking （前开后闭）技术，目的是为了解决Phantom Problem（幻象问题）

  Next-key locking技术是谓词锁（predict）的一种改进，此外还有previous-key locking技术（前闭后开）

###### 区间范围，解释：

```
假设Recoed Lock锁定的索引记录为 10、13、20；
Gap Lock锁定范围为：(-∞,10)、(10,13)、(13,20)、(20,+∞)；
Next-Key Lock锁定范围为：(-∞,10]、(10,13]、(13,20]、(20,+∞)；
previous-key locking技术锁定范围为：(-∞,10)、[10,13)、[13,20)、[20,+∞)；
```

###### 算法降级

当查询的列是唯一索引时，Next-Key Lock可以降级为Record Lock，从而提高并发性；

对于辅助索引，InnoDB不仅会对该锁定记录加上Next-key Lock，而且还会对索引的下一个键值加上Gap Lock；

### 2）解决Phantom Problem（幻象问题）

###### Phantom Problem

在同一事务下，连续执行两次同样的SQL语句，可能导致返回不同的结果集，第二次的SQL语句可能会返回之前不存在的行。

在默认的事务隔离级别（RR）下，InnoDB采用Next-key Locking技术来避免Phantom Problem（幻读问题）；

在默认的事务隔离级别（RR）下，使用Next-key Lock加锁；在事务隔离级别RC下，仅采用Record Lock加锁。

Tips：oracle需要在Serializable事务隔离级别下才能解决Phantom Problem。



## 五、锁问题

### 1）脏读

###### 脏读

在不同的事务下，当前事务可以读到其他事务为提交的数据（脏数据）。

###### 脏页与脏读

- 脏页：在缓冲池中被修改的，还未被刷新到磁盘的页；
- 脏读：事务对缓冲池行记录的修改，并且事务还未被提交；

脏读问题会在事务隔离级别：Read Uncommited（未提交读）下产生。

### 2）不可重复读

###### 不可重复读

在一个事务内多次地区同一数据集，其他事务对该数据集执行DML操作，多次读到的内容可能是不一样的。

###### 不可重复读与脏读

- 不可重复读：读到是的其他事务提交的数据；
- 脏读：读到的是其他事务为提交的数据。

在隔离级别RC下，是允许不可重复读问题的出现；

### 3）丢失更新

###### 丢失更新

一个事务的更新操作被另一个事务的更新操作覆盖，导致数据不一致。

在任何隔离级别下都不会导致丢失数据的问题出现。



## 六、阻塞

###### 阻塞

由于不同锁之间的兼容性问题，某些时刻，一个事务中的锁需要等待其他事务中的锁释放被锁定的资源。

参数：

innodb_lock_wait_time参数：可控制等待时间（默认50s）；

innodb_rollback_on_timeout参数：设定是否在超时等待时对进行中的事务进行回滚操作。



## 七、死锁





## 八、锁升级

###### 锁升级：将当前锁的粒度降低。

InnoDB不存在锁升级，采用位图方式，根据每个事务访问的每个页对锁进行管理，不管一个事务锁住的页中的一个记录还是多个记录，开销都是一样的。
