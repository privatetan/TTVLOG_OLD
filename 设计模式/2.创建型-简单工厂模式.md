# 简单工厂模式

## 一、简单工厂模式

**意图**：在创建对象时不暴露内部细节，只提供一个创建对象的通用接口。     

**主要解决**：知接口，但不知接口具体实现。

**何时使用**：当一个接口有多个实现类（固定且少）的时候。

**如何解决**： 它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。

**关键代码**：静态方法获取实例。所以又名：静态工厂方法。

## 二、优缺点

### 优点

- ###### 实现解耦

  实例的创建与使用隔离，使用者不关心类对象实例的创建，实现了解耦；

- ###### 实现可维护性

  工厂类完成对象实例化工作，使代码更容易维护。 

- ###### 符合面接口编程思想

  更符合面向对象的原则 & 面向接口编程，而不是面向实现编程。

### 缺点

- ###### 违背开闭原则

  新产品的增加需修改工厂类的逻辑，会造成工厂类逻辑复杂。

- ###### 使用静态工厂方法，无法形成基于继承的等级结构

  简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。



## 三、应用

- 客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；

- 当工厂类负责创建的对象（具体产品）比较少时。

- 开源代码中的使用：

  JDK中的java.util.Calendar.getInstance()方法使用了简单工厂。

  JDK中反射相关类使用了简单工厂：

  - java.lang.Class.newInstance()；
  - java.lang.Class.forName()，传入不同className，返回该类Class对象；
  - Java.lang.reflect.Proxy.newProxyInstance()；

  JDK8中的包装类Interger、Long、Short、Double等对象的valueOf()方法使用了简单工厂。

  Spring中的AbstractBeanFactory的getBean()方法使用了简单工厂；

  ###### 注意：

  ###### BeanFactory 的子接口 ConfigurableBeanFactory 接口运用了工厂方法，将 getBean 方法获取对象延迟到 ConfigurableBeanFactory 子类中实现。

  ###### Spring中的BeanFactory的getBean()方法使用了抽象工厂；
  
  

## 四、实现

### 1. 代码实现
