# 并发标记

并发标记，主要是为转移过程提供信息。

并发标记结束后，可以为转移处理提供如下信息

- 标记位图prev：并发标记完成时存活对象和死亡对象的区分；
- 存活对象字节数：prev_marked_bytes。

#### 注意

新对象在并发标记结束后被创建，会分配在prevTAMS和top之间，会被当成存活对象处理。



## 并发标记

##### 简单标记

可从根节点（GcRoots）直接触达的所有对象都会被添加标记，带标记的是存活对象，不带标记的是死亡对象。

简单标记中，标记线程的执行会暂停mutator的运行（即：STW）。

##### 并发标记

并发标记中，标记线程和 mutator的运行几乎是并发进行的。

需要注意的是，并发标记其实并不是直接在对象上添加标记，而是在**标记位图**上添加标记。



## 标记位图

##### 标记位图

将用于标记的比特值等信息单独拿出来放到其他地方，用来匹配对应的对象。

简言之，用于记录存活的对象。

每个区域（Region）带有两个标记位图

- next：本次标记的标记位图，保存本次标记的结果；
- prev：上次标记的标记位图，保存上次标记的结果。

标记位图中的每个比特（bit）都对应着关联区域内的对象的开头部分。



## 并发标记执行步骤

1. ##### 初始标记

   发生STW（暂停mutator的运行），标记可由根节点（GC Roots）直接引用的对象。

2. ##### 并发标记

   开启与mutator并发运行的线程，标记初始标记中标记的对象所引用的对象。

3. ##### 最终标记

   发生STW（暂停mutator的运行），标记”并发标记“中未被标记的对象。

4. ##### 存活对象计数

   开启与mutator并发运行的线程，统计每个区域（Region）中被标记的对象数量。

5. ##### 收尾工作

   发生STW（暂停mutator的运行），收尾工作，并未下次标记做准备。

### 初始标记

**发生STW（暂停mutator的运行），标记可由根节点（GC Roots）直接引用的对象。**

##### 初始标记步骤

1. **创建标记位图next**

   在初始标记阶段，GC线程首先会为每个区域（Regin）创建标记位图next，来保存本次标记的结果，此过程与mutator并发运行。

2. **根扫描**

   所有标记位图创建完成后，开始根扫描；

   根扫描：对根节点（GCRoots）直接引用对象的标记过程。

   该过程需暂停mutator运行；

   为什么不采用并发标记？因为大多数根（GCRoots）并不是对象，他们的修改并不能被写屏障获知，因此必须暂停mutator。

3. **开启mutator**

   完成根扫描后，开启mutator；

   未被扫描的对象将在后面的操作中标记；



### 并发标记

**开启与mutator并发运行的线程，标记”初始标记“中标记的对象所引用的对象。**

标记在初始标记阶段标记过的大部分对象；

使用“**SATB专用写屏障技术**”记录对象间引用的变化添加至SATB本地队列，避免“标记遗漏”问题。

**SATB队列集合**：用来记录标记过程中对象之间的引用关系。

### 最终标记

**发生STW（暂停mutator的运行），标记”并发标记“中未被标记的对象。**

**结束后，堆内所有存活对象都会被标记。**

扫描并处理在并发标记过程中记录在STAB本地队列的残留对象（因为未装满的STAB本地队列不会被添加到SATB队列集合）；

STAB本地队列的数据会被mutator操作，所以须暂停mutator执行。



### 存活对象计数

**开启与mutator并发运行的线程，统计每个区域（Region）中被标记的对象数量。**

扫描各个区域的标记位图next，统计区域内存活对象的字节数，然后将其存入区域内的`next_marked_bytes`中。

`prev_marked_bytes`存放了上次标记结束时存活对象的字节数。

计数处理时，转移处理可能会启动，则计数处理时需停掉记忆集合线程，因为计数过程中操作的对象也可能会被转移的记忆集合（remembered set）线程使用。



### 收尾工作

**发生STW（暂停mutator的运行），收尾工作，并未下次标记做准备。**

收尾工作操作的数据有些和mutator共享，则需要暂停mutator执行。

收尾工作包含的内容

1. ##### 移动标记位图next数据至标记位图prev

   收尾工作时，GC线程会逐个扫描每个区域（Region），将标记位图next中并发标记的结果移到标记位图prev后，重置标记位图next；

   扫描时，会计算每个区域（Region）的**转移效率**，并按照该效率对区域进行**降序**排序。

2. ##### 清除并回收区域（Region）

   清除即：标记-清除算法中的清除

   清除并回收不带标记对象的内存区域。

#### 转移效率

转移效率，表示**转移1个字节所需要的时间**。

**公式**：转移效率 = 死亡对象的字节数/转移存活对象所需时间

死亡对象越多，转移效率越高。