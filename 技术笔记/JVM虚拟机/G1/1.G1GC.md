# G1GC

G1GC最大特征是重视：**实时性**。

## 一、G1GC诞生





## 二、G1GC实时性

### 实时性

实时性要求：程序须在设定的**最后期限**（deadline）之前完成。

#### 实时性分类：

- ##### 硬实时性

  系统敏感度较高，如医疗机器人控制系统、航空管制系统等；

  这类系统中的处理超出了最后期限，很可能出现致命的问题；

  硬实时性的处理必须在处理开始后的很短时间内完成。

- ##### 软实时性

  系统敏感度较低，多用于稍微超出几次最后期限也没什么问题的系统中；

  软实时性的处理可以超出最后期限，但超出期限的频率很重要；

  只有超出频率在用户能够容忍范围之内的处理，我们才能说它具备软实时性

#### 可预测性

保证实时性方面，可预测性是一个重要的因素。

可预测性，是指：可以预测处理大约会耗费多长时间。

### G1GC实时性

G1GC具有**软实时性**。

G1GC的软实时性具有如下两个功能：

- ##### 设置期望暂停时间STW（最后期限deadline）

  支持用户自定义mutator暂停时间（STW）的功能；

  G1GC 具有软实时性，因此会尽力保证处理不超过该暂停时间。

- ##### 可预测性

  预测下次 GC 会导致 mutator 暂停多长时间的功能；

  根据预测出来的结果，G1GC 会通过**延迟执行 GC**、**拆分 GC 目标对象**等手段来遵守设置的期望暂停时间。

```
Tips: 一般会把运行在JVM上的用户Java程序称为 mutator.
```



## 三、G1GC堆结构

### 区域（Region）

G1GC的堆内部，被划分为大小相等的区域（Region），所有区域以**链表**结构排列。

G1GC以区域（Region）为单位完成GC工作。

区域（Region）大小默认为1MB，用户可随意设置区域（Region）大小，但内部将会用设置的值向上调整为 2 的指数幂（2^n ），并以该正数作为区域的大小。

如果正在分配对象的某个区域（Region）已经满了，GC 线程会寻找下一个空闲的区域来继续分配。

空闲区域是通过链表进行管理的，因此查找的时间复杂度是固定的 *O*(1)。



## 四、G1GC执行过程

G1GC执行时主要有两个功能：

- #### 并发标记（concurrent marking）

  并发标记基本能和 mutator 并发执行，会针对区域内所有的存活对象 A 进行标记。

  并发标记由**并发标记线程**来执行。

  **并发标记作用**：

  在尽量不暂停 mutator 的情况下标记出存活对象，并记录每个区域内存活对象的数量。

- #### 转移（evacuation）

  ##### 转移步骤

  1. 首先，从区域中选择一个进行GC 操作。如果该区域有存活对象，则将其复制到其他空闲区域。
  2. 当选择的空闲区域也满了的时候，GC 线程会再次选择其他空闲区域来存放存活对象。
  3. 对象复制完成之后，只剩下死亡对象 B 的区域会被重置为空闲区域以便复用。

  **转移作用**：

  将待回收区域内的存活对象复制到其他的空闲区域，然后将待回收区域重置为空闲状态，类似复制GC算法，区别是G1以区域进行。

  转移其实也起到了压缩（将存活对象挤到内存中同一侧的操作）的作用，因此 G1GC 中的区域不会发生碎片化。

#### 注意⚠️：并发标记和转移在处理上是相互独立的

并发标记的结果信息对于转移来说并不是必须的。

因此，转移处理可能发生在并发标记开始之前，也可能发生在并发标记的过程中。



## 五、并行GC与并发GC

G1GC算法组合使用了并行GC（Parallel GC）和并发GC（Concurrent GC）。

- #### 并行GC

  GC线程与mutator交替之行；

  先暂停mutator的运行，然后开启多个GC线程执行GC；

  **并行GC目的**：尽量缩短mutator的暂停时间；

- #### 并发GC

  GC线程与mutator同时执行；

  不暂停mutator线程，直接开启GC线程与mutator同时执行。

  **并发GC目的**：消除mutator暂停时间。

#### 注意：

1. 并行GC虽然需要暂停mutator运行，但是实现简单，并发GC不暂停mutator实现比较复杂。

2. 并发GC使用**增量式GC的写屏障技术**，解决在标记存活对象的时候，mutator修改引用关系的问题。
3. 并行GC与并发GC可以组合使用，如G1GC，大多情况采用并发GC，在个别需要暂停mutator的阶段采用并行GC；



## 六、写屏障与读屏障

- #### 写屏障

  用于获知对象的修改；

- #### 读屏障

  用于获知引用的读取；

  读屏障可以获知所有引用的读取，同时也能获知根的变更，使用读屏障就可以不用扫描根时暂停mutator了；

  读屏障有致命的缺点--慢，因为读取所有的引用对系统会造成很大的负担。

  