# 单例模式

## 一、单例模式

**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决：**一个全局使用的类频繁地创建与销毁。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码：**构造函数是私有的。



## 二、优缺点

### 优点：

1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。

2. 避免对资源的多重占用（比如写文件操作）。

### 缺点：

- 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

  

## 三、实现及

### 1. 实现单例模式的6种：

|  实现方式  |                             原理                             |                       优点                       |                             缺点                             |                应用场景                |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------: | :----------------------------------------------------------: | :------------------------------------: |
|   饿汉式   | 初始化时创建实例<br />依赖JVM类加载机制<br />保证单例只创建一次<br> | 线程安全<br />初始化速度快<br />内存占用小<br /> |                      单例创建时机不可控                      | 多线程场景<br />要求速度快内存小<br /> |
|   懒汉式   |  类加载时，将单例引用置为null<br/>需要时，创建单例实例<br/>  |                按需加载，节约资源                |                          线程不安全                          |           按需、延迟创建单例           |
|   同步锁   |           使用Synchronized同步锁锁住创建单例的方法           |                     线程安全                     | 每次访问都会加锁线程同步<br />造成过多的同步（加锁）开销<br /> |           按需、延迟创建单例           |
| 双重校验锁 | 校验锁1：若单例存在，直接返回该单例<br />校验锁2：防止多次创建单例实例<br /> |          线程安全<br/>减少同步开销<br/>          |                         实现较为复杂                         |           按需、延迟创建单例           |
| 静态内部类 | 按需加载：在装载静态内部类的时创建单例<br />线程安全：静态内部类由JVM加载且只加载一次 |  线程安全<br />减少同步开销<br />实现简单<br />  |                                                              |           按需、延迟创建单例           |
|    枚举    | 枚举类型：不可被继承<br />枚举元素：属类静态常量，<br />由JVM加载且只加载一次<br />枚举元素：通过静态代码块加载<br />构造方法：私有化<br />大部分方法都是final修饰 |   线程安全<br />自由序列化<br />实现简洁<br />   |                      单例创建时机不可控                      | 多线程场景<br />要求速度快内存小<br /> |

#### 特别提醒：

###### 懒汉式与饿汉式最大的区别：单例创建时机不同。

###### 实现单例模式的最佳实践是：枚举！！！

注意：如果不使用枚举来实现单例模式，会出现反射攻击。因为通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象。如果要防止这种攻击，需要在构造函数中添加防止实例化第二个对象的代码。

### 2. 代码实现



## 五、使用场景

开源代码中的使用：

- JDK 中 java.lang.Runtime 类，每个运行中的 Java 应用的环境信息；
- Spring 的单例 bean 的实现。Spring中的bean由IOC容器完成维护和管理。

