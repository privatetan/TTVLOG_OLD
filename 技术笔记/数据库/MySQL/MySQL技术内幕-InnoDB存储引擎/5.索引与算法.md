# 索引与算法

## 一、InnoDB索引

InnoDB支持的索引

- ###### B+树索引
  
  B+树索引是关系型数据库中最常用的索引类型；
  
  B+树索引的构造类似于二叉树，根据键值（key-vlaue）快速查找到数据。
  
  B+树中的B，代表平衡（Balance）而非二叉（Binary），B+树是从二叉树演化而来，但并非二叉树。
  
  B+树并不能找到一个给定值的具体行，B+索引查找的是数据行所在的页，数据库把页读到内存，然后在内存中进行查找数据。

- ###### 全文索引：
  
  MySQL5.6开始支持全文索引。
  
  使用全文索引前，搞清楚版本支持情况；
  
  全文索引比 like + % 快 N 倍，但是可能存在精度问题；
  
  如果需要全文索引的是大量数据，建议先添加数据，再创建索引；
  
  对于中文，可以使用 MySQL 5.7.6 之后的版本（引入ngram全文分析器），或者第三方插件。

- ###### 哈希索引
  
  InnoDB支持的哈希索引是自适应的：会根据表的使用情况自动为表生成哈希索引，不能人为干预。

## 二、数据结构与算法

### 二分查找法

二分查找法（binary search），又名折半查找法，用来查找一组有序元素数组的某一元素；

基本思想：将元素有序排列，按跳跃式查找，即，将有序数组的中间元素与目标元素进行对比，根据对比来缩小查找范围，每次比较，查找区间缩小一半。

### 二叉查找树和平衡二叉树

###### 二叉查找数

在二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。

二叉树可以任意构造，但是链式二叉树（？暂译）性能是非常低的。

若想最大性能的构造棵二叉查找树，需要这棵树是平衡的即：平衡二叉树，又名AVL树。

###### 平衡二叉树

平衡二叉树，又AVL树，满足二叉查找树的定义，重要是必须满足任何节点的两个子树高度的高度差为1；

平和二叉树查询效率高，但是维护一棵平衡二叉树代价是非常大的：通常需要一次或者N次左旋和右旋来得到插入或更新后树的平衡。

## 三、B+树

B+树，是由B树和索引顺序访问方法（ISAM）演化而来；

B+树，是为磁盘或其他存储辅助设备设计的一组平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。

### B+树的插入操作

B+的插入必须保证插入后叶子节点的记录依然排序；

B+树插入的3种情况：

| Leaf Page满 | Index Page 满 | 操作                                                                                                                                                  |
|:----------:|:------------:|:--------------------------------------------------------------------------------------------------------------------------------------------------- |
| No         | No           | 直接将记录插入到叶子节点                                                                                                                                        |
| Yes        | No           | 1.拆分Leaf Page<br/>2.将中间的节点放入到Index Page中；<br/>3.小于中间节点的记录放在左边；<br/>4.等于或大于中间节点的记录放右边。                                                               |
| Yes        | Yes          | 1.拆分Leaf Page<br/>2.小于中间节点的记录放在左边；<br/>3.等于或大于中间节点的记录放右边；<br/>4.拆分Index Page<br/>5.小于中间节点的记录放在左边；<br/>6.等于或大于中间节点的记录放右边；<br/>7.中间节点放入上一层Index Page。 |

为了保持平衡，对于新插入的键值，可能需要做大量的拆分页（split）操作；

因为B+树结构主要用于磁盘，页的拆分意味着磁盘的操作，所以应尽可能少的减少页的拆分操作；

B+提供了类似于平衡二叉树旋转（Rotation）功能，来减少页的拆分。

### B+树的删除操作

B+树使用填充因子（fill factor）来控制树的删除变化，50%是填充因子的最小值。

B+的删除也必须保证删除后叶子节点的记录依然排序；

B+树删除的3种情况：

| 叶子节点小于填充因子 | 中间节点小于填充因子 | 操作                                                                 |
|:----------:|:----------:| ------------------------------------------------------------------ |
| No         | No         | 直接将记录从叶子节点删除，<br/>如果该节点还是Index Page的节点，<br/>该节点的右节点代替。             |
| Yes        | No         | 合并叶子节点和它的兄弟节点，同时更新Index Page。                                      |
| Yes        | Yes        | 1. 合并叶子节点和它的兄弟节点；<br/>2. 更新Index Page；<br/>3. 合并Index Page和它的兄弟节点。 |

## 四、B+树索引

B+树在数据库中有一个高扇出性，在数据库中，B+树的高度一般在2～4层；

B+树中索引可分为：**聚集索引**（Clustered index）和**辅助索引**（Secondary index）

不管是聚集还是辅助索引，内部都是B+树，叶子节点存放着所有的数据；

聚集和辅助不同的是，叶子节点存放的是否是一整行数据。

### 聚集索引

聚集索引，是根据表的主键构造的一棵B+树，叶子节点存放表的行记录数据，叶子节点称为数据页；

聚集索引中，索引组织表中数据也是索引的一部分；

数据页只能按照一棵B+树进行排序，所以每张表只能有一个聚集索引。

大多情况下，查询优化器倾向于采用聚集索引，因为聚集索引能够在B+树索引的叶子节点直接找到数据。由于定义了数据的逻辑顺序，聚集索引能够特别快的访问仅对范围值的查询。

聚集索引中：数据页存储的是完整的行记录，非数据页存储的是键值及指向数据页的偏移量。

聚集索引存储并不是物理上连续的，而是逻辑上连续的，原因有二：

1. 页是通过双向表链接，页按照主键的顺序排序；

2. 每个页中的记录也是通过双向链表维护，物理存储上可以不按照主键存储。

聚集索引的另一个好处是：对于主键的排序查找和范围查找速度非常快。

### 辅助索引

辅助索引：又非聚集索引，叶子节点并不包含行记录的全部数据。

叶子节点存放键值、可以找到行数据的书签（书签就是行数据的聚集索引键）；

每张表可以有多个辅助索引；

通过辅助索引查找数据时，InnoDB会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后通过主键索引来找到完整的行记录。

### B+树索引分裂

B+树索引页分裂并不总是从页的中间记录开始的，因为从中间开始会导致页空间的浪费。如果插入是根据自增序列进行的，分裂之后，左边的页如果有空闲的空间，也不会有记录被插入，导致空间浪费。

### B+树索引管理

#### 索引管理

创建/删除索引的方法

- alter table  add/drop index

- create/drop index

查看表索引

- show index from table
  
  show index 结果中的每条含义
  
  | 属性           | 含义           | 备注                                                                   |
  |:------------:|:------------:|:--------------------------------------------------------------------:|
  | Table        | 索引所在表        |                                                                      |
  | Not_unique   | 非唯一的索引       |                                                                      |
  | Key_name     | 索引的名字        | 可根据改名字执行DROP Index                                                   |
  | Seq_in_index | 索引中该列的位置     |                                                                      |
  | Column_name  | 索引列的名称       |                                                                      |
  | Collation    | 列存储在索引中的方式   | A or NULL，B+树索引为A，即排序；<br/>如果使用Hash索引则为NULL                          |
  | Cardinality  | 基数           | 很关键，表示索引中唯一值的数目估计值。<br/>Cardinality表的行数应尽可能接近1，<br/>如果非常小，则考虑是否可删除索引 |
  | Sub_part     | 是否是列的部分被索引   | 如果部分索引显示具体数值，全部索引显示NULL                                              |
  | Packed       | 关键字如何被压缩     | 没有被压缩，则为NULL                                                         |
  | Null         | 是否索引列含有NULL值 |                                                                      |
  | Index_type   | 索引的类型        | innoDB只支持B+树，显示Btree                                                 |
  | Comment      | 注释           |                                                                      |

其中Cardinality值是非常关键的，优化器会根据该值来判断是否使用这个索引。

### Fast Index Creation

数据库的DDL操作步骤：

1. 创建一张结构为alter table 定义的临时表；

2. 将原表数据导入临时数据；

3. 删除原表；

4. 将临时表更名为原表。

从InnoDB 1.0.x版本开始，InnoDB支持Fast Index Creation（快速创建索引，简称FIC）的索引创建方式；

FIC在对辅助索引操作时，不需要重建表，会对表加上S锁（Share，共享锁），操作过程中只能对表进行读操作；

FIC方式仅限定于辅助索引，对于主键索引的操作同样需要重建一张临时表。

### Online Schema Change

Online Schema Change（在线架构改变，简称OSC），是Facebook实现的在线执行DDL的方式。

### Online DDL

从MySQL5.6开始，支持Oline DDL（在线数据定义）：允许辅助索引创建的同时，还允许Insert、Update、Delete等DML，提高MySQL数据库的可用性；

alter语法

```sql
ALTER TABLE table_name
| ADD {INDEX|KEY} [index_name]
[index_type] (index_col_name,...) [index_option] ...
ALGORITHM [=] {DEFAULT|INPLACE|COPY}
LOCK [=] {DEFAULT|NONE|SHARE|EXCLUSIVE}
```

ALGORITHM参数指定了创建或删除索引的算法：

- Copy：表示按照MySQL5.1版本前的工作模式，即创建临时表的方式。

- Inplace：表示索引的创建/删除不需要创建临时表。

- Default：表示根据参数old_alter_table来判断使用Copy还是Inplace，默认为OFF，即采用Inplace方式。

LOCK参数表示索引创建/删除时对表的加锁情况：

- None：对表不加锁，读写事务都不会阻塞，该模式式可获得最大并发度；

- Share：对表加S锁（读锁），读事务不阻塞，写事务阻塞，存储若不支持Share模式，返回一个信息。

- Exclusive：对表加X锁（写锁），读写事务阻塞；

- Default：根据None--->Share--->Exclusive顺序判断是否使用那种方式，Default会通过判断事务最大的并发性判断执行DDL的模式。

##### Online DDL的实现原理：

在执行创建/删除操作的同时，将Insert、Update、Delete这类DML操作日志写入到一个缓存中。待完成索引创建后再将重做应用到表上，以此达到数据一致性。

## 

## 五、Cardinality-基数值

### Cardinality-基数

Cardinality基数，表示去重后唯一值（Unique Values）的数量。

列基数，列基数是列包含的不重复值的数量。

高选择性与低选择性

- 高选择性：字段取值范围很广，几乎没有重复；

- 低选择性：字段取值范围很小，如性别，年龄等；

B+树索引在高选择性字段上添加是最合适的。

查看cardinality：show index from table；

cardinality是一个预估值，不是一个准确值；

在实际应用中，cardinality应尽可能的接近1；

### InnoDB中的Cardinality统计

Cardinality的统计实在存储引擎层进行的；

数据库对于Cardinality统计是通过采样（Sample）的方式完成的。

InnoDB中Cardinality统计信息的更新发生在：nsert 和 Update 操作；

###### 更新策略：

1. 表中1/16的数据发生过变化；

2. stat_modified_counter（变化次数计数器）>=20 0000 0000。

###### 采样过程：

1. 取得B+树索引中叶子节点的数量，记作A；

2. 随机取得B+树索引中8（innodb_stats_sample_pages默认值）个叶子节点，统计每个页不同记录的个数，记作P1,P2...P8；

3. 根据采样信息给出Cardinality的预估值：Cardinality = （P1+P2+...+P8）*A/8。

## 六、B+树索引的使用

### 联合索引

联合索引：对表上的多个列进行索引。

联合索引，本质上是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2；

联合索引，在B+树中键值都是排序的，通过叶子节点可以逻辑上顺序地读出所有数据；

对于（a,b）联合索引，查询情况：

1. a=xxx：叶子节点上对a进行排序，可通过二分法查找，索引生效；

2. b=yyy：a值不确定，b无序，索引失效；

3. a=xxx and b=yyy：叶子节点上对a进行排序，可通过二分法查找，a确定时，再对b进行排序，亦可进行二分查找，索引生效。

联合索引失效原因：就是未遵循索引列的排序规则；

### 覆盖索引

覆盖索引：索引覆盖，即从辅助索引中就可以查询到的记录；

使用覆盖索引时，辅助索引不包含整行记录的信息，大小远小于聚集索引，可以减少大量的IO操作。

### 优化器选择不使用索引

优化器进行选择辅助索引查找时，如果查询的数据不能索引覆盖，则还需要进行一次书签访问（回表查询），虽然辅助索引有序，但是书签访问无序；当访问数据量很小，优化器会选择辅助索引，当访问数据占整个表中的数据的20%及以上时，优化器会选择聚集索引来查找数据。

可通过关键字Force Index 来强制使用某个索引。

### 索引提示（Index Hint）

索引提示：index hint，显示的告诉优化器使用索引；

使用场景：

- 优化器错误的选择了某个索引，导致SQL运行很慢。
- SQL可使用的索引非常多，优化器选择执行计划时间开销可能大雨SQL语句本身。

### Multi-Range Read（MRR） 优化

Multi-Range Read：MRR优化，目的是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，提升IO-bound类型的SQL查询效率。

MRR优化可适用于range、ref、eq_ref类型的查询。

### Index Condition Pushdown（ICP）优化

Index Condition Pushdown：ICP优化，在数据库取出索引的同时，判断是否可以进行where条件过滤，将where过滤操作放在存储引擎层，提高SQL查询效率；

ICP优化支持range、ref、eq_ref、ref_or_null类型的查询，支持InnoDB和MyISAM存储引擎；

## 七、哈希算法

哈希算法，时间复杂度是O(1)，每个数据库都应存在这样的数据结构；

### 哈希表

哈希表：又名散列表，由直接寻址表改进而来；

在数据库中，哈希表采用链接法（拉链法）解决哈希碰撞；

### InnoDB中的哈希算法

InnoDB中，使用链接法（拉链法）解决哈希冲突，使用除法散列实现哈希函数。

### 自适应哈希索引

自适应哈希索引，采用哈希表实现；

自适应哈希索引是数据库自身创建并使用，不能人为干预。

自适应哈希索引，对于精确查找很快，对于范围查询是失效的。

使用innodb_adaptive_hash_index来禁用或启用自适应哈希索引，默认开启。

## 八、全文检索（技术）

全文检索：可以将存储于数据库的任意内容查找出来；

MyISAM支持全文检索，InnoDB 从1.2.x版本开始支持全文检索；

### 倒排索引

全文检索通常使用倒排索引来实现；

倒排索引，Inverted index，是一种索引结构。

倒排索引，在辅助索表中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。

映射关系利用关联数组实现，拥有两种表现形式：

- Inverted file index，表现形式为{单词，单词所在文档的ID}
- full inverted index，表现形式为{单词，(单词所在文档的ID，在具体文档中的位置)}

### InnoDB全文检索

InnoDB从1.2.x开始支持全文检索技术，采full inverted index倒排索引实现；

InnoDB中，将（DocumentId，Position）视为一个“ilist”，因此在全文检索的辅助表（Auxiliary Table）中，有两个列：word字段，ilist字段，在word字段上设有索引，此外InnoDB在ilist中存放Position信息，可以进行Proximity Search，而MyISAM不支持该特性。

Auxiliary Table：辅助表，持久表，存放于磁盘上，共有6张辅助表；

FTS Index Cache：全文检索索引缓存，用来提高全文检索性能，其数据结构是一个红黑树，根据（word，ilist）进行排序。

InnoDB全文检索限制

- 每张表只有一个全文检索的索引；
- 多列组成的全文是检索的索引列必须使用相同的字符集与排序规则；
- 不支持没有单词界定符的语言，如中文、日语、韩语等；

### 全文检索

全文检索语法：

```sql
select * from table where
MATCH (column1,column2...) AGAINST (expr [search_modifier])
```

search_modifier，查询模式：

- ###### In Natural Language Mode

  默认模式，表示查询带有指定word的文档，可省略查询模式的编写

- ###### In Boolean Mode

  使用该模式，查询字符串的前后字符会有特殊意义：

  例子：

  ````sql
  select * from fts_a where
  MATCH (body) AGAINST ('+Pease -hot' In Boolean Mode)
  ````

  操作符号：

  - +：表示该word必须存在；
  - -：表示该word必须被排除；
  - （on operator）：表示该word式可选的；
  - @distance：表示查询的多个单词之间的距离是否在distance之内，distance的单位是字节，这种全文检索称为Proximity Search。
  - \>：表示出现该单词时增加相关性；
  - \<：表示出现该单词时降低相关性；
  - ～：表示允许出现该单词；
  - \*：表示以该单词开头的单词；
  - \"：表示短语；

- ###### In Natural Language Mode With Query Expansion

- ###### With Query Expansion

  In Natural Language Mode With Query Expansion & With Query Expansion：全文检索扩展查询；

  通常在查询的关键词太短，用户需要implied knowledge（隐含知识） 时进行。例如，查询database单词时，把MySQL、Oracle等也查询出来。

  该查询分为两个阶段：

  1. 根据搜索的单词进行全文检索查询；
  2. 根据第一阶段产生的分词在进行一次全文检索查询。

  
