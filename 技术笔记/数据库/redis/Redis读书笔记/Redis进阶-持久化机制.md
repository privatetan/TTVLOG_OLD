# Redis 进阶-持久化机制

## 为什么需要持久化？

Redis是个基于内存的数据库。如果服务宕机，内存中的数据将全部丢失；

**解决数据丢失**

* **数据库恢复**：1. 大量数据会对数据库带来巨大的压力，2. 数据库的性能不如Redis；

* **数据持久化**；

## 持久化方式

官方文档上能够看到的Redis对持久化存储的支持明确的就只有两种方案：**RDB **与 **AOF**；

## RDB持久化（数据快照）

#### RDB 程序将当前内存中的数据库快照保存到磁盘文件中；

在 Redis 重启动时， RDB 程序可以通过载入 RDB 文件来还原数据库的状态。

由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值；

### 使用RDB

* ##### 手动触发

手动触发分别对应 **save** 和 **bgsave**命令；

```properties
* save命令: 阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间阻塞，线上环境不建议使用;
* bgsave命令: Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短;
```

###### fork是类Unix操作系统上**创建进程**的主要方法。fork用于**创建子进程**(等同于当前进程的副本)。

* ##### 自动触发

在以下4种情况时会自动触发

```json
1. redis.conf中配置save <m> <n>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件； 
2. 主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；
3. 执行debug reload命令重新加载redis时也会触发bgsave操作； 
4. 默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作。
```

相关配置

```python
# 周期性执行条件的设置格式为
save <seconds> <changes>

# 默认的设置为：
save 900 1         //如果900秒内有1条Key信息发生变化，则进行快照；
save 300 10        //如果300秒内有10条Key信息发生变化，则进行快照;
save 60 10000      //如果60秒内有10000条Key信息发生变化，则进行快照;

# 以下设置方式为关闭RDB快照功能
save ""
```

 其它相关配置

```python
# 文件名称：RDB文件在磁盘上的名称。
dbfilename dump.rdb

# 文件保存路径：RDB文件的存储路径。默认设置为“./”，也就是Redis服务的主目录
dir /home/work/app/redis/data/

# 如果持久化出错，主进程是否停止写入
stop-writes-on-bgsave-error yes

# 是否压缩：该属性将在字符串类型的数据被快照到磁盘文件时，启用LZF压缩算法；
rdbcompression yes

# 导入时是否检查：
##从RDB快照功能的version 5 版本开始，一个64位的CRC冗余校验编码会被放置在RDB文件的末尾，以便对整个RDB文件的完整性进行验证；
##这个功能大概会多损失10%左右的性能，但获得了更高的数据可靠性。
rdbchecksum yes
```

### 实现原理

RDB 功能最核心的是 `rdbSave` 和 `rdbLoad` 两个函数， 

* ##### rdbSave（保存）

  用于生成 RDB 文件到磁盘， 如果 RDB 文件已存在， 那么新的 RDB 文件将替换已有的 RDB 文件。

  ###### sava与bgsave

  ```python
  # save命令：阻塞当前Redis服务器主线程，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用;
  # bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短;
  ```

  ###### sava与bgsave伪代码：

  ````python
  # save 方法
  def SAVE(): 
      # 阻塞主进程，直到持久化完成
      rdbSave(); 
      
  # bgsave方法
  def BGSAVE():
      #fock一个子线程，该操作会阻塞主线程；
      pid = fork() 
      if pid == 0:  #pid == 0，表示子线程调用，pid>0表示，父线程调用，pid<0，表示创建子线程失败，
          # 子进程保存 RDB
          rdbSave()
      elif pid > 0:
          # 父进程继续处理请求，并等待子进程的完成信号
          handle_request()
      else:
          # pid == -1
          # 处理 fork 错误
          handle_fork_error()
  ````

  ###### save 、 bgsave 、 AOF 写入和 bgrewriteaof 

* ##### rdbLoad（加载）

  用于将 RDB 文件中的数据重新载入到内存中。

  当 Redis 服务器启动时， `rdbLoad` 函数就会被执行， 它读取 RDB 文件， 并将文件中的数据库数据载入到内存中。

  发布与订阅功能和其他数据库功能是完全隔离的，前者不写入也不读取数据库，所以在服务器载入期间，订阅与发布功能仍然可以正常使用，而不必担心对载入数据的完整性产生影响。

  因为 AOF 文件的保存频率通常要高于 RDB 文件保存的频率， 所以一般来说， AOF 文件中的数据会比 RDB 文件中的数据要新。

  因此， 如果服务器在启动时， 打开了 AOF 功能， 那么程序优先使用 AOF 文件来还原数据。 只有在 AOF 功能未打开的情况下， Redis 才会使用 RDB 文件来还原数据。

### 扩展问题

1. ##### 在RDB数据持久化时，持续时间较长，会有新的写入数据，如何保证数据一致性？

 在RDB中采用COW（Copy On Write，写时复制）机制，来保证在持久化时的数据一致性问题，即：

```python
# 在进行RDB数据持久化时，Redis会调用fork创建一个子线程进行数据持久化操作，而主线程会继续运行，并接受读写请求；
# 当有新写请求时，Redis主线程将目标数据备份，并在备份数据上进行修改操作；
# 子线程完成持久化操作后，会对备份数据进行处理并持久化。
```

COW存在问题

如果子进程存在期间，发生了大量的写操作，那可能就会出现**很多的分页错误(页异常中断page-fault)**，这样就得耗费不少性能在复制上；

[详解cow](https://juejin.cn/post/6844903702373859335)

2. ##### 在进行快照操作的这段时间，如果发生服务崩溃怎么办？

在没有将数据全部写入到磁盘前，这次快照操作都不算成功。

如果出现了服务崩溃的情况，将上一次完整的RDB快照文件作为恢复内存数据的参考。

在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。

3. **可以每秒做一次快照吗**？

虽然 bgsave 执行时不阻塞主线程，但是，**如果频繁地执行全量快照，也会带来两方面的开销**

```python
# 磁盘压力：频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。 
# fork()频繁阻塞主线程：bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。
```

### RDB优缺点

- **优点**
  - RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；
  - Redis加载RDB文件恢复数据要远远快于AOF方式；
- **缺点**
  - RDB方式实时性不够，无法做到秒级的持久化；
  - 每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；
  - RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；
  - 版本兼容RDB文件问题；

针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。



## AOF持久化（协议文本）

#### AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件；

AOF持久化日志采用**写后**日志，即**先写内存，后写日志**；

日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存；

**PS**: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。

**为什么采用写后日志**？

```python
# 好处： 1.避免额外的检查开销， 2.不会阻塞当前的写操作；
# 风险： 1.如果命令执行完成，写日志之前宕机了，会丢失数据， 2.主线程写磁盘压力大，导致写盘慢，阻塞后续操作；
```

### 使用AOF

##### redis.conf中配置AOF

默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下:

```python
# appendonly参数开启AOF持久化：默认情况下AOF功能是关闭的，将该选项改为yes以便打开Redis的AOF功能。
appendonly no

# AOF持久化的文件名，默认是appendonly.aof
appendfilename "appendonly.aof"

# AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的
dir ./

# 同步策略 (三种)：这个参数项是AOF功能最重要的设置项之一，主要用于设置“真正执行”操作命令向AOF文件中同步的策略。
# appendfsync always
appendfsync everysec  #默认设置
# appendfsync no

# aof重写期间是否同步
##Redis提供了这个设置项，保证在完成fsync函数调用时，不会将这段时间内发生的命令操作放入操作系统的Page Cache
no-appendfsync-on-rewrite no

# 重写触发配置：用来控制Redis中自动对AOF文件进行重写的情况，如果是技术人员手动调用“BGREWRITEAOF”命令，则不受这两个限制条件左右
auto-aof-rewrite-percentage 100 #表示如果当前AOF文件的大小超过了上次重写后AOF文件的百分比后，就再次开始重写AOF文件；
auto-aof-rewrite-min-size 64mb #表示如果AOF文件大小低于这个值，则不会触发重写操作。

# 加载aof出错如何处理
aof-load-truncated yes

# 文件重写策略
aof-rewrite-incremental-fsync yes

```

AOF保存模式

````
Always，同步写回：
   每个写命令执行完，立马同步地将日志写回磁盘；
   可靠性高，数据基本不会丢失，每个命令都会刷盘，性能影响大；
Everysec，每秒写回：
   每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
   性能适中，宕机时最多丢失2s数据；
No，操作系统控制的写回：
   每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘；
   性能好，宕机数据丢失较多；
````

上面的三种写回策略体现了一个重要原则：**trade-off**，取舍，指在性能和可靠性保证之间做取舍。

关于AOF的同步策略是涉及到操作系统的 write 函数和 fsync 函数的，在《Redis设计与实现》中是这样说明的：

```
为了提高文件写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。

这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了fsync、fdatasync同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。
```

### AOF同步

同步命令到 AOF 文件的整个过程可以分为三个阶段：

* #### 命令传播

  Redis 将执行完的命令、命令的参数、命令的参数个数等信息发送到 AOF 程序中。

  每当Redis命令函数成功执行之后， 命令参数都会被传播到 AOF 程序， 以及 Replication程序；

  这个执行并传播命令的过程可以用以下伪代码表示：

  ```python
  if (execRedisCommand(cmd, argv, argc) == EXEC_SUCCESS):
      if aof_is_turn_on():
          # 传播命令到 AOF 程序
          propagate_aof(cmd, argv, argc)
      if replication_is_turn_on():
          # 传播命令到 REPLICATION 程序
          propagate_replication(cmd, argv, argc)
  ```

* #### 缓存追加

  AOF 程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将**协议内容**追加到服务器的 AOF 缓存中。

  协议文本生成之后， 它会被追加到 `redis.h/redisServer` 结构的 `aof_buf` 末尾；

  `redisServer` 结构维持着 Redis 服务器的状态， `aof_buf` 域则保存着所有等待写入到 AOF 文件的协议文本：

  ```c
  struct redisServer {
      //其他域...
      sds aof_buf;
      // 其他域...
  };
  ```

* #### 文件写入（Write）和保存（save）

  AOF 缓存中的内容被写入到 AOF 文件末尾，如果设定的 AOF 保存条件被满足的话， `fsync` 函数或者 `fdatasync`函数会被调用，将写入的内容真正地保存到磁盘中。

  每当服务器常规任务函数被执行、 或者事件处理器被执行时， `aof.c/flushAppendOnlyFile` 函数都会被调用， 这个函数执行以下两个工作：

  * ##### Write：根据条件，将 `aof_buf` 中的缓存**写入**到 AOF 文件。

  * ##### Save：根据条件，调用 `fsync` 或 `fdatasync` 函数，将 AOF 文件**保存**到磁盘中。

  `aof.c/flushAppendOnlyFile`伪代码

  ```python
  func flushAppendOnlyFile{
      if(write):
         # 将 aof_buf 中的缓存**写入**到 AOF 文件
         write_aof_file()
      if(save):
         # 将 AOF 文件保存到磁盘中
         fsync()
  } 
  ```

  两个步骤都需要根据一定的条件来执行， 而这些条件由 AOF 所使用的保存模式来决定， 以下小节就来介绍 AOF 所使用的三种保存模式， 以及在这些模式下， 步骤 Write 和 Save 的调用条件。

### AOF保存模式（写回策略）

Redis 目前支持三种 AOF 保存模式，它们分别是：

* ##### `AOF_FSYNC_NO` ：不保存。

  在这种模式下， 每次调用 `flushAppendOnlyFile` 函数， WRITE 都会被执行， 但 SAVE 会被略过。

  在这种模式下， SAVE 只会在以下任意一种情况中被执行：

  - Redis 被关闭；
  - AOF 功能被关闭；
  - 系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行）。

  这三种情况下的 SAVE 操作都会引起 Redis 主进程阻塞。

* ##### `AOF_FSYNC_EVERYSEC` ：每一秒钟保存一次。

  在这种模式中， SAVE 原则上每隔一秒钟就会执行一次， 因为 SAVE 操作是由后台子线程调用的， 所以它不会引起服务器主进程阻塞。

  在实际运行中， 程序在这种模式下对 `fsync` 或 `fdatasync` 的调用并不是每秒一次， 它和调用 `flushAppendOnlyFile` 函数时 Redis 所处的状态有关；

  每当 `flushAppendOnlyFile` 函数被调用时， 可能会出现以下四种情况：

  - 子线程正在执行 SAVE ，并且：

    ```
    1. 这个 SAVE 的执行时间未超过 2 秒，那么程序直接返回，并不执行 WRITE 或新的 SAVE 。
    2. 这个 SAVE 已经执行超过 2 秒，那么程序执行 WRITE ，但不执行新的 SAVE 。注意，因为这时 WRITE 的写入必须等待子线程先完成（旧的） SAVE ，因此这里 WRITE 会比平时阻塞更长时间。
    ```

  - 子线程没有在执行 SAVE ，并且：

    ```
    3. 上次成功执行 SAVE 距今不超过 1 秒，那么程序执行 WRITE ，但不执行 SAVE 。
    4. 上次成功执行 SAVE 距今已经超过 1 秒，那么程序执行 WRITE 和 SAVE 。
    ```

​       如果在情况 2 中发生故障停机， 那么用户损失的数据是可以超过 2 秒的。    

* ##### `AOF_FSYNC_ALWAYS` ：每执行一个命令保存一次。

  在这种模式下，每次执行完一个命令之后， WRITE 和 SAVE 都会被执行。

  因为 SAVE 是由 Redis 主进程执行的，所以在 SAVE 执行期间，主进程会被阻塞，不能接受命令请求。

  

  ##### 三个模式比较

| 模式                 | WRITE 是否阻塞？ | SAVE 是否阻塞？ | 停机时丢失的数据量                                    |
| :------------------- | :--------------- | :-------------- | :---------------------------------------------------- |
| `AOF_FSYNC_NO`       | 阻塞             | 阻塞            | 操作系统最后一次对 AOF 文件触发 SAVE 操作之后的数据。 |
| `AOF_FSYNC_EVERYSEC` | 阻塞             | 不阻塞          | 一般情况下不超过 2 秒钟的数据。                       |
| `AOF_FSYNC_ALWAYS`   | 阻塞             | 阻塞            | 最多只丢失一个命令的数据。                            |

### AOF文件读取和数据还原

AOF 文件保存了 Redis 的数据库状态， 而文件里面包含的都是符合 Redis 通讯协议格式的命令文本；

只要根据 AOF 文件里的协议， 重新执行一遍里面指示的所有命令， 就可以还原 Redis 的数据库状态了。

 AOF 文件并还原数据库的详细步骤如下：

```
1、创建一个不带网络连接的伪客户端（fake client）；
2、读取 AOF 所保存的文本，并根据内容还原出命令、命令的参数以及命令的个数；
3、根据命令、命令的参数和命令的个数，使用伪客户端执行该命令；
4、循环执行 2 和 3 ，直到 AOF 文件中的所有命令执行完毕。
```

 AOF 文件并还原数据库的伪代码如下：

```python
def READ_AND_LOAD_AOF():
    # 打开并读取 AOF 文件
    file = open(aof_file_name)
    while file.is_not_reach_eof():
        # 读入一条协议文本格式的 Redis 命令
        cmd_in_text = file.read_next_command_in_protocol_format()
        # 根据文本命令，查找命令函数，并创建参数和参数个数等对象
        cmd, argv, argc = text_to_command(cmd_in_text)
        # 执行命令
        execRedisCommand(cmd, argv, argc)
    # 关闭文件
    file.close()
```

###### 为了避免对数据的完整性产生影响， 在服务器载入数据的过程中， 只有和数据库无关的订阅与发布功能可以正常使用， 其他命令一律返回错误。

### AOF重写

AOF的同步方式会造成一个问题： **随着运行时间的流逝， AOF 文件会变得越来越大**。

为了解决以上的问题， Redis 需要对 AOF 文件进行**重写（rewrite）**：

######  创建一个新的 AOF 文件来代替原有的 AOF 文件， 新 AOF 文件和原有 AOF 文件保存的数据库状态完全一样， 但新 AOF 文件的体积小于等于原有 AOF 文件的体积。

### AOF重写的实现

###### 根据键的类型， 使用适当的写入命令来重现键的当前值， 这就是 AOF 重写的实现原理。

除了列表和集合之外， 字符串、有序集、哈希表等键也可以用类似的方法来保存状态， 并且保存这些状态所使用的命令数量， 比起之前建立这些键的状态所使用命令的数量要大大减少。

### AOF后台重写（AOF重写缓存）

Redis在执行AOF重写程序的时候， 调用者线程会被阻塞，则将 AOF 重写程序放到（后台）子进程里执行（类似RDB的bgsave命令）；

* 子线程处理最大好处：

  ```
  1. 子进程进行 AOF 重写期间，主进程可以继续处理命令请求。
  2. 子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。
  ```

* 子线程处理最大问题：

  ```
  因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。
  ```

解决数据不一致问题：

   Redis 增加了一个 AOF 重写缓存： 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外， 还会追加到这个缓存中。

AOF重写缓存步骤：

```
1. 处理命令请求。
2. 将写命令追加到现有的 AOF 文件中。
3. 将写命令追加到 AOF 重写缓存中。
```

AOF重写缓存伪代码：

```python
def REWRITE_CACHE_AOF():
  #写入现有AOF文件
  WRITE_INTO_AOF()
  #写入AOF重写缓存
  WRITE_INTO_CACHE_AOF()
```

完成AOF缓存重写：

当子进程完成 AOF 重写之后， 它会向父进程发送一个完成信号， 父进程在接到完成信号之后， 会调用一个信号处理函数， 并完成以下工作：

```
1. 将 AOF 重写缓存中的内容全部写入到新 AOF 文件中。
2. 对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。
```

整个 AOF 后台重写过程中， 只有最后的写入缓存和改名操作会造成主进程阻塞， 在其他时候， AOF 后台重写都不会对主进程造成阻塞， 这将 AOF 重写对性能造成的影响降到了最低。

### AOF 后台重写的触发条件

* 手动触发：调用 BGREWRITEAOF命令手动触发。

* 自动触发：

  服务器在 AOF 功能开启的情况下， 会维持以下三个变量：

  ```
  - 记录当前 AOF 文件大小的变量 `aof_current_size` 。
  - 记录最后一次 AOF 重写之后， AOF 文件大小的变量 `aof_rewrite_base_size` 。
  - 增长百分比变量 `aof_rewrite_perc` 。
  ```

  每次当 `serverCron` 函数执行时， 它都会检查以下条件是否全部满足， 如果是的话， 就会触发自动的 AOF 重写：

  ```tex
  1. 没有 BGSAVE 命令在进行。
  2. 没有 BGREWRITEAOF 在进行。
  3. 当前 AOF 文件大小大于 server.aof_rewrite_min_size （默认值为 1 MB）。
  4. 当前 AOF 文件大小和最后一次 AOF 重写后的大小之间的比率大于等于指定的增长百分比。
  ```

  默认情况下， 增长百分比为 `100%` ， 也即是说， 如果前面三个条件都已经满足， 并且当前 AOF 文件大小比最后一次 AOF 重写时的大小要大一倍的话， 那么触发自动 AOF 重写。

### AOF小结

```
AOF 文件通过保存所有修改数据库的命令来记录数据库的状态。
AOF 文件中的所有命令都以 Redis 通讯协议的格式保存。
不同的 AOF 保存模式对数据的安全性、以及 Redis 的性能有很大的影响。
AOF 重写的目的是用更小的体积来保存数据库状态，整个重写过程基本上不影响 Redis 主进程处理命令请求。
AOF 重写是一个有歧义的名字，实际的重写工作是针对数据库的当前值来进行的，程序既不读写、也不使用原有的 AOF 文件。
AOF 可以由用户手动触发，也可以由服务器自动触发。
```

## RDB与AOF混合模式（v4.0）

内存快照RDB以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。

## 持久化数据恢复

###### 从持久化文件中恢复数据，只需要重新启动Redis即可。

如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？

```tex
1、redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件； 
2、如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动； 
3、若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功；
4、如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；
```

