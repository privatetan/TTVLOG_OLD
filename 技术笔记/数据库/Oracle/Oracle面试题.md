# Oracle面试题

## 1、Delete 与Truncate区别？

1. Truncate 是DDL 语句，Delete 是DML语句。

2. Truncate 的速度远快于Delete；
   
   原因是： 当执行DELETE操作时所有表数据先被COPY到回滚表空间，数据量不同花费时间长短不一。而TRUNCATE 是直接删除数据不进回滚表空间。

3. Delete 数据可以运行Rollback 进行数据回滚。而Truncate 则是永久删除不能回滚。
4) Truncate 操作不会触发表上的Delete触发器，而Delete 会正常触发。
5. Truncate 语句不能带where 条件意味着只能全部数据删除，而Delete可带where 条件进行删除数据。

6. Truncate 操作会重置表的高水位线（High Water Mark），而Delete 不会。

## 2、集合操作符

Union ： 不包含重复值，默认按第一个查询的第一列升序排列。

Union All : 完全并集包含重复值。不排序。

Minus 不包含重复值，不排序。

## 3、数据库的三大范式是什么？

- 第一范式：原子件，要求每一列的值不能再拆分了。

- 第二范式：一张表只描述一个实体（若列中有冗余数据，则不满足）；

- 第三范式： 所有列与主键值直接相关。

## 4、事务的特性（ACID）是指什么？

- 原子性（Atomic）： 事务中的各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败。

- 一致性（Consistent）： 事务结束后系统状态是一样的。

- 隔离性（Isolated）: 并发执行的事务彼此无法看到对方的中间状态。

- 持久性（Durable）:事务完成后，即使发生灾难性故障，通过日志和同步备份可以在故障发生后重建数据。

## 5、Mysql数据库与Oracle 数据库有什么区别？

- ###### 应用方面
  
  Mysql 是中小型应用的数据库。一般用于个人和中小型企业；
  
  Oracle 属于大型数据库，一般用于具有相当规模的企业应用。

- ###### 自动增长的数据类型方面：
  
   MySQL有自动增长的数据类型；
  
  Oracle 没有自动增长的数据类型。需要建立一个自增序列。

- ###### group by 用法：
  
   Mysql 中group by 在SELECT 语句中可以随意使用；
  
  Oracle 中如果查询语句中有组函数，那么其他列必须是组函数处理过的或者是group by子句中的列，否则会报错。

- ###### 引导方面：
  
  MySQL中可以用单引号、双引号包起字符串；
  
  Oracle 中只可以用单引号包起字符串。

## 7 . 如何使用Oracle的游标？

游标：

1. oracle中的游标分为显示游标和隐式游标 
2. 显示游标是用cursor...is命令定义的游标，它可以对查询语句(select)返回的多条记录进行处理；隐式游标是在执行插入 (insert)、删除(delete)、修改(update)和返回单条记录的查询(select)语句时由PL/SQL自动定义的。 
3. 显式游标的操作：打开游标、操作游标、关闭游标；PL/SQL隐式地打开SQL游标，并在它内部处理SQL语句，然后关闭它

## 8、Oracle中function和procedure的区别？

function：函数，

proceduce：存储过程，

1. 函数可以理解是存储过程的一种；
2. 函数可以没有参数,但是一定需要一个返回值，存储过程可以没有参数,不需要返回值；
3. 函数return返回值没有返回参数模式，存储过程通过out参数返回值, 如果需要返回多个参数则建议使用存储过程；
4. 在sql数据操纵语句中只能调用函数而不能调用存储过程。

## 9、Oracle的导入导出有几种方式，有何区别？

1. 使用oracle工具 exp/imp ，导入/导出的是二进制的数据；
2. 使用plsql相关工具，导入/导出的是sql语句的文本文件。

## 10、解释什么是死锁，如何解决Oracle中的死锁？

死锁：存在加了锁而没有解锁，客户端处于等在状态；

原因：可能是使用锁没有提交或者回滚事务，如果是表级锁则不能操作表，客户端处于等在状态，如果是行级锁则不能操作锁定行

查看：

```sql
select b.owner,b.object_name,a.session_id,a.locked_mode
from v$locked_object a,dba_objects b 
where b.object_id = a.object_id; 

select b.username,b.sid,b.serial#,logon_time 
from v$locked_object a,v$session b 
where a.session_id = b.sid order by b.logon_time;
```

解决死锁：

```sql
alter system kill session "sid,serial#";
```

## 11、简述oracle中 dml、ddl、dcl的使用

DML数据操纵语言，如select、update、delete，insert；
DDL数据定义语言，如create table 、drop table 等等；
DCL数据控制语言， 如commit、 rollback、grant、 invoke等。

## 12、怎样创建一个一个索引

- ###### 创建标准索引：
  
  ```sql
  CREATE INDEX 索引名 ON 表名 (列名) TABLESPACE 表空间名; 
  ```

- ###### 创建唯一索引:
  
  ```sql
  CREATE unique INDEX 索引名 ON 表名 (列名) TABLESPACE 表空间名; 
  ```

- ###### 创建组合索引:
  
  ```sql
  CREATE INDEX 索引名 ON 表名 (列名1,列名2) TABLESPACE 表空间名; 
  ```

- ###### 创建反向键索引:
  
  ```sql
  CREATE INDEX 索引名 ON 表名 (列名) reverse TABLESPACE 表空间名;
  ```

## 13、索引使用的原则

1. 索引字段建议建立NOT NULL约束 ；
2. 经常与其他表进行连接的表，在连接字段上应该建立索引； 
3. 经常出现在Where子句中的字段且过滤性很强的，特别是大表的字段，应该建立索引； 
4. 可选择性高的关键字 ，应该建立索引； 
5. 可选择性低的关键字，但数据的值分布差异很大时，选择性数据比较少时仍然可以利用索引提高效率；
6. 复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替： 
   A、正确选择复合索引中的第一个字段，一般是选择性较好的且在where子句中常用的字段上； 
   B、复合索引的几个字段经常同时以AND方式出现在Where子句中可以建立复合索引；否则单字段索引； 
   C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； 
   D、如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； 
   E、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引； 
7. 频繁DML的表，不要建立太多的索引； 
8. 不要将那些频繁修改的列作为索引列；

## 14、索引的优缺点

- ### 优点
  
  1. 创建唯一性索引，保证数据库表中每一行数据的唯一性 
  2. 加快检索速度，这也是创建索引的最主要的原因 
  3. 加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义；
  4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 

- ### 缺点：
  
  1. 索引创建在表上，不能创建在视图上；
  2. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加；
  3. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大；
  4. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。

## 15、oracle的锁

分类

1. 行共享锁 (ROW SHARE) 
2. 行排他锁(ROW EXCLUSIVE) 
3. 共享锁(SHARE) 
4. 共享行排他锁(SHARE ROW EXCLUSIVE) 
5. 排他锁(EXCLUSIVE)

使用

```sql
SELECT * FROM order_master WHERE vencode="V002" FOR UPDATE WAIT 5; 
LOCK TABLE order_master IN SHARE MODE; 
LOCK TABLE itemfile IN EXCLUSIVE MODE NOWAIT;
```

## 16、oracle的锁的分类

- #### 按用户与系统划分，可以分为自动锁与显示锁
  
  - 自动锁：当进行一项数据库操作时，缺省情况下，系统自动为此数据库操作获得所有有必要的锁。 
  - 显示锁：某些情况下，需要用户显示的锁定数据库操作要用到的数据，才能使数据库操作执行得更好，显示锁是用户为数据库对象设定的。 

- #### 按锁级别划分，可分为共享锁与排它锁
  
  - 共享锁：共享锁使一个事务对特定数据库资源进行共享访问——另一事务也可对此资源进行访问或获得相同共享锁。
    
    共享锁为事务提供高并发性，但如拙劣的事务设计+共享锁容易造成死锁或数据更新丢失。 
  
  - 排它锁：事务设置排它锁后，该事务单独获得此资源，另一事务不能在此事务提交之前获得相同对象的共享锁或排它锁。 

- #### 按操作划分，可分为DML锁、DDL锁
  
  - ###### DML锁又可以分为，行锁、表锁、死锁
    
    - 行锁：当事务执行数据库插入、更新、删除操作时，该事务自动获得操作表中操作行的排它锁。 
    - 表级锁：当事务获得行锁后，此事务也将自动获得该行的表锁(共享锁),以防止其它事务进行DDL语句影响记录行的更新。事务也可以在进行过程中获得共享锁或排它锁，只有当事务显示使用LOCK TABLE语句显示的定义一个排它锁时，事务才会获得表上的排它锁,也可使用LOCK TABLE显示的定义一个表级的共享锁(LOCK TABLE具体用法请参考相关文档)。 
    - 死锁：当两个事务需要一组有冲突的锁，而不能将事务继续下去的话，就出现死锁。 
      如事务1在表A行记录#3中有一排它锁，并等待事务2在表A中记录#4中排它锁的释放，而事务2在表A记录行#4中有一排它锁，并等待事务; 1在表A中记录#3中排它锁的释放，事务1与事务2彼此等待，因此就造成了死锁。死锁一般是因拙劣的事务设计而产生。死锁只能使用SQL下:alter system kill session "sid,serial#"；或者使用相关操作系统kill进程的命令，如UNIX下kill -9 sid,或者使用其它工具杀掉死锁进程。 
  
  - ###### DDL锁又可以分为：排它DDL锁、共享DDL锁、分析锁
    
    - 排它DDL锁：创建、修改、删除一个数据库对象的DDL语句获得操作对象的 排它锁。如使用alter table语句时，为了维护数据的完成性、一致性、合法性，该事务获得一排它DDL锁。 
    - 共享DDL锁：需在数据库对象之间建立相互依赖关系的DDL语句通常需共享获得DDL锁。 
      如创建一个包，该包中的过程与函数引用了不同的数据库表，当编译此包时，该事务就获得了引用表的共享DDL锁。 
    - 分析锁：ORACLE使用共享池存储分析与优化过的SQL语句及PL/SQL程序，使运行相同语句的应用速度更快。一个在共享池中缓存的对象获得它所引用数据库对象的分析锁。分析锁是一种独特的DDL锁类型，ORACLE使用它追踪共享池对象及它所引用数据库对象之间的依赖关系。当一个事务修改或删除了共享池持有分析锁的数据库对象时，ORACLE使共享池中的对象作废，下次在引用这条SQL/PLSQL语句时，ORACLE重新分析编译此语句。 

- #### 内部闩锁
  
  内部闩锁：这是ORACLE中的一种特殊锁，用于顺序访问内部系统结构。当事务需向缓冲区写入信息时，为了使用此块内存区域，ORACLE首先必须取得这块内存区域的闩锁，才能向此块内存写入信息。