# 运行时数据区域篇

## 1、什么是Java虚拟机？

Java虚拟机是一个可以执行Java字节码的虚拟机进程；

## 2、堆与栈区别？

### 数据结构

- 堆：完全二叉树；
- 栈：先进后出（FILO）的线性数据结构；

### 内存区域

- #### 堆内存

  - 线程共享区域；
  - 存放是对象实例，及对象的一些属性值：如常量；
  - 堆空间较大；
  - 会发生OOM异常；

- #### 栈内存

  - 线程私有区域；
  - 是java方法执行时的内存区域，方法进入进栈，方法退出出栈；
  - 栈空间较小；
  - 会发生OOM和SOF异常；

## 3、Java内存结构

### 线程共享区

- #### 堆
  
  **特性**：Java虚拟机内存最大的区域；“内存分配”与“垃圾回收”的主要区域；
  
  **内存划分**：
  
  - 内存分配角度：分为多个“线程私有的分配缓冲区（TLAB）”；
  - 垃圾回收角度：分代收集，分为“新生代”，“老年代”，“永久代（JDK1.8，元空间取代之）”；
  
  **存放**：Java对象实例；

- #### 方法区
  
  **特性**：堆内存的逻辑区，又名“非堆”；JDK1.8前称为“永久代”，之后由“元空间”代之；
  
  **存放**：已被虚拟机加载的，类型信息、常量、静态变量、即时编译器后的代码缓存等数据；

- #### 运行时常量池
  
  **特性**：方法区的一部分；
  
  **存放**：常量池表， 即编译器生成的各种“字面量”和“符号引用”；

### 线程私有区

- #### 程序计数器
  
  **特性**：线程执行的字节码的行号指示器；用作流程控制：循环跳转，方法跳转等；

- #### 虚拟机栈
  
  **特性**：Java方法执行的内存区域；方法执行时创建，每个方法都会创建一个栈帧；
  
  **存放**：局部变量表(基本数据类型、对象引用、returnAddress类型)、操作数栈、动态链接、方法出口等信息；

- #### 本地方法栈
  
  **特性**：与虚拟机栈作用相似；Native方法（Unsafe类）执行的线程内存模型；

# 对象篇

## 1、对象创建流程？

1. 类加载检查；
2. 分配内存：堆规整，指针碰撞；不规整，空闲列表；
3. 初始化零值；
4. 设置对象头：运行时数据、类型指针，数组长度（如果是数组对象）
5. 执行\<init>()指令调用类构造方法完成对象实例化。

## 2、对象结构/组成/内存布局？

- 对象头：运行时数据，类型指针，数组长度；
- 实例数据：对象的有效信息；
- 对齐填充：满足8k对齐；

## 3、对象访问方式？

1. 句柄：堆中维护句柄池，稳定；
2. 指针：直接指向对象，速度快；

## 4、异常OOM与SOF？

- ### SOF
  
  Stack Overflow，Memory Leak，内存泄漏；
  
  发生内存区域：栈内存区（虚拟机栈、本地方法栈）；
  
  发生原因：资源（流、数据库连接）未及时释放；线程请求的栈深大于虚拟机允许的深度；递归太深导致堆栈溢出产生；
  
  发生场景：递归调用；大量循环或死循环；数组、List、map数据过大；流、数据库连接资源未释放；

- ### OOM：
  
  Out Of Memory，内存溢出，内存不足；
  
  发生区域：除了程序计数器之外的内存区域；
  
  发生原因：虚拟机在扩展内存区域时无法申请到足够的内存空间；
  
  发生场景：内存不足不够分配；

- ### 如何应对：
  
  首先，通过内存映像分析工具（如Eclipse Memory Analyzer），对dump出来的堆转存快照进行分析，确认内存中的对象是否是必要的。
  
  然后，分清是因为内存泄漏(Stack Overflow)还是内存溢出(Out Of Memory)。
  
  - 如果是内存泄漏：可进一步通过工具查看泄漏对象到GCRoots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收；
  - 如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。

## 5、对象分配规则？

1. 优先在Eden区分配：空间不够发起MinorGC/YongGC；
2. 大对象直接进入老年代：避免新生代发生大量内存复制；
3. 长期存活对象进入老年代：一次MinorGC，年龄+1，超过阈值（15）进入老年代；
4. 动态对象年龄判定：Eden区同岁对象大小大于剩余空间大小，同岁及长者对象可进入老年代；
5. 空间分配担保规则：老年代剩余连续空间不足，可设置空间分配担保规则避免重复发生FullGC；

## 6、分配担保规则

在即将发生GC时：

- 首先判断老年代剩余的连续的空间大小是否大于新生代对象的大小？
- 满足则进行MinorGC，不满足判断是否运行进行分配担保？
- 不允许则进行FullGC，允许则判断老年代剩余的连续的空间大小是否大于历代新生代晋升对象的平均大小？
- 满足则进行MinorGC，不满足进行FullGC。

## 7、GC类型？

```
1、MinorGC/YongGC：新生代GC；
2、MajorGC/OldGC：老年代GC，仅CMS垃圾回收器；
3、MixedGC：混合GC，仅G1垃圾回收器；
4、FullGC：Java堆与栈GC；
```

## 8、什么时候发生Full GC？

```
1.调用System.gc；
2.老年代内存不足；
3.老年代内存不足且分配担保失败；
```

# 垃圾回收篇

## 1、为什么要进行垃圾回收？

```
垃圾回收区域：java堆，方法区；
回收原因：垃圾的回收是为了更好的分配内存；
```

## 2、对象判活算法？

##### 引用计数器

```
* 在对象中添加一个引用计数器；
* 每当引用它时，计数器就+1；当引用失效，计数器-1；
* 计数器为0的对象，就是不可再用的。
```

##### 可达性分析

```
* 通过“GC Roots“的根对象作为起始节点集向下搜索（路径称为：引用链）；
* 如果某个对象到GC Roots间没有任何引用链相连，证明对象不可能再使用。
```

## 3、GC Roots？

##### GC Roots都是对象

```
虚拟机栈(本地变量表)中引用的对象；
方法区中的静态属性、常量引用的对象；
被同步锁(Synchronized)持有的对象；
本地方法栈中JNI(Native方法)引用的对象；
Java虚拟机内部引用: 基本数据类型对应的Class对象、类加载器等。
```

## 4、可达性分析中的两次标记，最后的补救？

```
* 第一次标记: 是否与GC Roots相连，
     - 是，存活，
     - 否，有无必要执行finalize()方法；
          - 无，宣告死亡，
          - 有，放入F-Queue队列(由Finalizer线程去执行Finalize()方法)；
* 第二次标记： 对F-Queue中的对象，有无重新引用，
     - 有，存活，
     - 无，死亡。
```

## 5、对象的引用？

```
强引用：只要强引用存在,就不会被回收的对象; Object
软引用：在将要发生内存溢出异常前的第二次回收后还没有足够内存,才抛出内存溢出异常; SoftReference
弱引用：生存到下次垃圾回收的对象; WeakReference
虚引用：唯一目的为了能在回收这个对象时收到系统通知; PhantomReference
```

## 6、垃圾回收算法？

##### 新生代：标记-复制；

##### 老年代：标记-清除（产生碎片）、标记-整理。

##### 分代收集算法

为什么新生代使用“标记-复制”，老年代使用“标记-清除/整理”？

结合三种方式的优缺点分析。

## 7、垃圾回收器？

##### 新生代（标记-复制）

```
* Serial：单线程，标记-复制，搭配Serial Old使用；
* PerNew：支持并发，Serial的多线程版本，标记-复制，搭配CMS使用；
* Parallel Scavenge：支持并行，注重吞吐量，标记-复制，搭配Parallel Old使用；
```

##### 老年代（标记-清除（产生碎片）、标记-整理）

```
* Serial Old：单线程，Serial的老年代版本，标记-整理，CMS的后备预案；
* Parallel Old：Parallel Scavenge的老年代版本，标记-整理，搭配搭配Parallel Scavenge使用
* CMS：
   -获取最短停顿时间为目标；
   -标记-清除
   -过程：初始标记、并发标记、重新标记、并发清除；
   -缺点：对CPU资源敏感；无法处理浮动垃圾；内存产生大量碎片；
```

##### 新型

```
G1：
  -Regin划分堆内存，按优先级回收；
  -步骤：初始标记、并发标记、最终标记、筛选回收；
```

# JVM调优篇

## 1、调优命令？

```
* jps：显示指定系统内所有的HotSpot虚拟机进程；
* jstat：监视虚拟机运行时状态信息，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据；
* jmap：生成heap dump文件；
* jhat：与jmap搭配使用，用来分析jmap生成的dump，可以在浏览器中查看分析结果；
* jstack：用于生成java虚拟机当前时刻的线程快照；
* jinfo：查看和调整虚拟机运行参数；
```

## 2、调优工具？

##### JDK自带

```
* jconsole：从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控;
* jvisualvm：jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。
```

##### 第三方

```
* MAT：基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗;
* GChisto：一款专业分析gc日志的工具;
```

## 3、JVM核心参数？

```
虚拟机栈：-Xss
java堆：-Xms -Xmx
永久代：-XX:PermSize -XX:MaxPermSize
JDK1.8后，使用Meta Space替代了Perm Space，MetaSpace大小默认没有限制，一般根据系统内存的大小。JVM会动态改变此值。
-XX:MetaspaceSize：分配给类元数据空间的初始值；
-XX:MaxMetaspaceSize：分配给类元数据空间的最大值，超过此值会触发FullGC，此值默认没有限制，取决于系统内存的大小。JVM会动态地改变此值。
```

# 类加载机制篇

## 1、什么是类加载？

虚拟机把描述类的Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型。

## 2、类的生命周期？

加载、验证、准备、解析、初始化、使用、卸载；

## 3、类加载阶段？

* 加载：将字节流转化为一个类的Class文件；
* 验证：为了确保字节流中包含的信息的安全性；
* 准备：为类变量分配内存，并设置初始值；
* 解析：虚拟机将常量池中的符号引用替换为直接引用；
* 初始化：执行类构造器\<clinit>()方法；

## 4、什么时候触发类加载器加载类（类加载时机）？

 当在程序中出现对于一个类的**主动引用**时，如果当前类尚未被加载到方法区中时，会触发对引用类的加载；

## 5、类加载器？

* **启动类加载器**：BootStrap ClassLoader，虚拟机的一部分，加载“\bin”目录下的类；
* **扩展类加载器**：Extension ClassLoader，加载\bin\ext目录下的类；
* **程序类加载器**：Application ClassLoader，加载\classpath用户类路径上文件；

除启动类加载器外，类加载器都应有自己的父类加载器；

加载器的父子关系不是继承，而是使用“**组合**”方式来复用父加载器的代码；

## 6、双亲委派模型工作过程（什么是双亲委派机制）？

1. 类加载器接收到加载请求时，将请求委派给父类加载器加载，直至顶层（启动类加载器）；

2. 当父类加载器反馈不能加载时，子类加载器才会去尝试加载。

## 7、双亲委派机制的好处（为什么要遵循双亲委派模型）

##### 通过双亲委派模型组织类加载器之间的关系，使得在Java中的类随着它的类加载器也具备了一种带优先级的层次关系，而这种关系**保证了类加载的安全性**；

如用户自己定义了一个Object类，按照双亲委派模型，首先会通过启动类加载器进行Object类的加载，则会加载在<JAVA_HOME>\lib目录下的Obejct.Class类，而不会加载用户在自身classpath下定义的Object类，从而保证了Java核心类库的类不会被错误的加载。

## 8、破坏双亲委派？

- #### 上层组件依赖下层组件的问题：JDBC
  
  在JDBC4.0开始，开始支持使用 SPI 的方式来注册 Driver ，扫描 META-INF/services/java.sql.Driver文件，使用线程上下文类加载器（ThreadContextClassLoader），破坏了双亲委派机制。
  
  ```
  线程上下文类加载器（Thread Context ClassLoader），在启动类加载器中获取应用程序类加载器。 Thread.setContextClassLoaser() 设置线程上下文类加载器，如果创建线程的时候没有设置，会从父类继承一个，默认应用程序类加载器。
  线程上下文使用不当可能会导致内存泄漏的问题：是引用使用不当导致一些本来在方法栈退出之后需要释放的引用无法释放导致的。
  ```

- #### 缺乏隔离性问题：Tomcat
  
  对于在一个JVM上会运行多个Web容器的Tomcat，类可见性如果处理不够妥当，**会导致Web容器间缺乏合理的隔离性从而带来安全性和容器间依赖组件版本冲突以及无法支持类热更的问题；**
  
  - ##### 破坏双亲委派机制
    
    Tomcat容器通过复写ClassLoader::loadClass()方法自定义了破坏双亲委派模型的WebappClassLoader类加载器解决隔离性问题。
  
  - ##### 解决共性依赖
    
    Tomcat容器中的共性依赖通过父加载器SharedClassLoader进行加载在Web应用间共享的jar包。
  
  - ##### 实现热更新
    
    Tomacat实现热更新：只需要动态替换掉Web容器的WebAppClassLoader即可，避免了重启整个Java项目带来的损耗，并不需要担心被替换掉的类加载器所加载的类会不会被运行在同一个JVM上的Web应用引用的问题。

- #### 总结
  
  1. 类加载器的双亲委派模型通过ClassLoader::loadClass()方法通过组合父加载器实现优先父加载器加载的模型。
  
  2. loadClass()：一般用于实现类加载器模型，诸如双亲委派模型，Tomcat类加载器模型等；
     
     findClass()：则用于在定义当前类加载器模型下当前类加载器具体的加载类手段。
  
  3. 自己实现类加载器，如果按照双亲委派模型，则只需要复写findClass()方法即可；
     
     如果需要破坏双亲委派模型，则需要复写loadClass()方法`与`findClass()方法。
     
     [参考链接](https://juejin.cn/post/6992057279755337741)

# Java内存模型篇（JMM）

## 1、什么是Java内存模型？

```
用来屏蔽各种硬件和操作系统的内存访问差异，让java程序在各种平台下达到一致的访问效果；
是围绕并发过程中如何处理原子性、有序性和可见性来建立的；
```

## 2、主内存与工作内存？

```
* 工作内存：线程私有，每个线程工作的区域；
* 主内存：线程共享，存储成员变量的区域；
```

##### 模型特点：

```
1，所有的成员变量都存储在主内存；
2，每条线程都有自己的工作内存；
3，线程的工作内存保存并使用主线程变量的副本拷贝；
4，线程对变量的所有操作（赋值）都在工作内存；
5，不同线程不能直接访问对方工作内存中的变量；
6，线程间的通信依靠主内存来完成；
```

## 3、内存间的交互操作（8种）？

```
* 主线程：lock，unlock，read，write；
* 工作内存：load，use，assign，store。
```

## 4、先行发生原则（8条）？

##### 判断数据是否存在竞争，线程是否安全的重要依据；

```properties
1. 程序次序原则: 按照代码书写顺序，书写在前面的操作先行发生于书写后面的操作；
2. 管程锁定原则: 一个unlock操作先行发生于后面对同一锁的lock操作；
3. volatile变量规则: 对volatile变量的写操作先行发生于后面对该变量的读操作；
4. 线程启动原则: Thread对象的start()方法先行发生于此线程的每一个操作；
5. 线程终止原则: 线程中的所有操作都先行发生于对此线程的终止检测；
6. 线程中断对则: 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断的发生；
7. 传递性: 如果A先行发生于B，B先行发生于C，则A先行发生于C；
```

## 5、volatile变量？

##### volatile，是java最轻量级的同步机制；

##### 特性

```properties
可见性: 通过强制刷新变量值到主内存实现；
有序性: 通过内存屏障指令实现；
```

### ！！！注意：volatile需要加锁来实现原子性

## 6、可见性、有序性、原子性？

```
* 可见性：强制刷新工作内存值到主内存实现的；
* 有序性：volatile通过内存屏障实现，Synchronized通过“一个变量一个时刻只允许一条线程对其进行lock操作”实现；
* 原子性：Sychronized关键字，显式或隐式地使用monitorenter和monitorexit指令来实现的；
```
