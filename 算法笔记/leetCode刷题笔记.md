## 算法套路

操作队列、栈：LinkedList

倒序操作：队列（LinkedList）

操作链表： Node

有序数组找元素：二分法

树的遍历：递归

二叉树、BFS（广度优先搜索，层序遍历）：利用队列（先进先出特性）





递归函数的时间复杂度：递归函数调用的次数 x 递归函数本身的复杂度

## 做递归思考三步：

1. #### 递归的函数要干什么？

   - 函数的作用是判断传入的两个树是否镜像。
   - 输入：TreeNode left, TreeNode right
   - 输出：是：true，不是：false

2. #### 递归停止的条件是什么？

   - 左节点和右节点都为空 -> 倒底了都长得一样 ->true
   - 左节点为空的时候右节点不为空，或反之 -> 长得不一样-> false
   - 左右节点值不相等 -> 长得不一样 -> false

3. #### 从某层到下一层的关系是什么？

   - 要想两棵树镜像，那么一棵树左边的左边要和二棵树右边的右边镜像，一棵树左边的右边要和二棵树右边的左边镜像
   - 调用递归函数传入左左和右右
   - 调用递归函数传入左右和右左
   - 只有左左和右右镜像且左右和右左镜像的时候，我们才能说这两棵树是镜像的

4. #### 调用递归函数，我们想知道它的左右孩子是否镜像，传入的值是root的左孩子和右孩子。这之前记得判个root==null。





## 动态规划

什么是动态规划问题：最优性算法，题型：求最值

经典问题：最长递增子序列，最长公共子序列、最小编辑距离、最长回文子序列、斐波那契数列、零钱兑换问题

动态规划问题核心：穷举

动态规划特点：1. 重叠子问题，2. 状态转移方程（关键），3. 最优子结构

动态规划解题套路：1.明确状态，2.明确选择，3. 明确db函数/数组的定义， 4. 明确base、case



#### 动态规划解法代码框架

```c
//初始化 base case
dp[0][0][...] = base
//状态转移(穷举)
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
       for ...
         //状态转移方程
         dp[状态1][状态2][...] = 求最值（选择1，选择2...）
```



